# Story 4.4: Themes and Accessibility

## Status
Draft

## Story
**As an** analyst,
**I want** to customize the interface appearance and ensure accessibility,
**so that** I can work comfortably and efficiently in different environments.

## Acceptance Criteria
1: Users can switch between light and dark themes
2: Users can customize accent colors
3: Interface supports keyboard navigation for all major functions
4: All components meet WCAG 2.1 AA accessibility standards
5: Interface supports screen readers and assistive technologies
6: Theme preferences are saved between sessions

## Tasks / Subtasks
- [x] Implement theme system (AC: 1)
  - [x] Create theme context and provider
  - [x] Implement dark theme styles
  - [x] Implement light theme styles
  - [x] Add theme toggle component

- [x] Implement color customization (AC: 2)
  - [x] Create color picker component
  - [x] Implement accent color system
  - [x] Add color presets
  - [x] Create color customization UI

- [x] Implement keyboard navigation (AC: 3)
  - [x] Add keyboard shortcuts for major actions
  - [x] Implement focus management
  - [x] Create keyboard navigation help dialog
  - [x] Add keyboard shortcut indicators

- [x] Implement accessibility features (AC: 4, 5)
  - [x] Add ARIA attributes to components
  - [x] Implement screen reader support
  - [x] Create high contrast mode
  - [x] Add text size adjustment
  - [x] Implement focus indicators

- [x] Implement preference persistence (AC: 6)
  - [x] Create preferences storage service
  - [x] Implement theme preference saving
  - [x] Add color preference saving
  - [x] Create accessibility preference saving

## Dev Notes

### Theme System Architecture
[Source: architecture/technical-architecture-document.md#ui-architecture]

Create a theme context and provider:

```typescript
// Theme types
export type ThemeMode = 'light' | 'dark' | 'system';
export type AccentColor = 'blue' | 'green' | 'purple' | 'orange' | 'red' | 'custom';

export interface ThemePreferences {
  mode: ThemeMode;
  accentColor: AccentColor;
  customAccentColor?: string;
  highContrast: boolean;
  fontSize: 'small' | 'medium' | 'large';
}

export interface ThemeContextType {
  theme: ThemePreferences;
  currentMode: 'light' | 'dark'; // Resolved mode (accounting for system preference)
  setThemeMode: (mode: ThemeMode) => void;
  setAccentColor: (color: AccentColor) => void;
  setCustomAccentColor: (color: string) => void;
  toggleHighContrast: () => void;
  setFontSize: (size: 'small' | 'medium' | 'large') => void;
  resetToDefaults: () => void;
}

// Default theme preferences
const defaultThemePreferences: ThemePreferences = {
  mode: 'system',
  accentColor: 'blue',
  highContrast: false,
  fontSize: 'medium'
};

// Create theme context
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Theme provider component
export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<ThemePreferences>(() => {
    // Load saved preferences from local storage
    try {
      const savedTheme = localStorage.getItem('themePreferences');
      return savedTheme ? JSON.parse(savedTheme) : defaultThemePreferences;
    } catch (error) {
      console.error('Error loading theme preferences:', error);
      return defaultThemePreferences;
    }
  });
  
  // Determine current mode based on system preference
  const [currentMode, setCurrentMode] = useState<'light' | 'dark'>(
    theme.mode === 'system'
      ? window.matchMedia('(prefers-color-scheme: dark)').matches
        ? 'dark'
        : 'light'
      : theme.mode
  );
  
  // Update theme preferences
  const updateTheme = (updates: Partial<ThemePreferences>) => {
    setTheme(prev => {
      const newTheme = { ...prev, ...updates };
      
      // Save to local storage
      localStorage.setItem('themePreferences', JSON.stringify(newTheme));
      
      return newTheme;
    });
  };
  
  // Listen for system theme changes
  useEffect(() => {
    if (theme.mode === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      
      const handleChange = (e: MediaQueryListEvent) => {
        setCurrentMode(e.matches ? 'dark' : 'light');
      };
      
      mediaQuery.addEventListener('change', handleChange);
      
      return () => {
        mediaQuery.removeEventListener('change', handleChange);
      };
    } else {
      setCurrentMode(theme.mode);
    }
  }, [theme.mode]);
  
  // Apply theme to document
  useEffect(() => {
    // Apply theme class to document
    document.documentElement.classList.remove('theme-light', 'theme-dark');
    document.documentElement.classList.add(`theme-${currentMode}`);
    
    // Apply high contrast if enabled
    if (theme.highContrast) {
      document.documentElement.classList.add('high-contrast');
    } else {
      document.documentElement.classList.remove('high-contrast');
    }
    
    // Apply font size
    document.documentElement.classList.remove('font-small', 'font-medium', 'font-large');
    document.documentElement.classList.add(`font-${theme.fontSize}`);
    
    // Apply accent color
    document.documentElement.style.setProperty(
      '--accent-color',
      theme.accentColor === 'custom' && theme.customAccentColor
        ? theme.customAccentColor
        : `var(--${theme.accentColor})`
    );
  }, [currentMode, theme]);
  
  // Create context value
  const contextValue = useMemo<ThemeContextType>(() => ({
    theme,
    currentMode,
    setThemeMode: (mode) => updateTheme({ mode }),
    setAccentColor: (accentColor) => updateTheme({ accentColor }),
    setCustomAccentColor: (customAccentColor) => 
      updateTheme({ accentColor: 'custom', customAccentColor }),
    toggleHighContrast: () => updateTheme({ highContrast: !theme.highContrast }),
    setFontSize: (fontSize) => updateTheme({ fontSize }),
    resetToDefaults: () => updateTheme(defaultThemePreferences)
  }), [theme, currentMode]);
  
  return (
    <ThemeContext.Provider value={contextValue}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook for using theme
export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  
  return context;
};
```

### Theme Styles
Create CSS variables for themes:

```css
/* Base theme variables */
:root {
  /* Light theme colors (default) */
  --background-primary: #ffffff;
  --background-secondary: #f5f5f5;
  --background-tertiary: #e9e9e9;
  --text-primary: #1a1a1a;
  --text-secondary: #555555;
  --text-tertiary: #888888;
  --border-color: #dddddd;
  --shadow-color: rgba(0, 0, 0, 0.1);
  
  /* Accent colors */
  --blue: #2563eb;
  --green: #10b981;
  --purple: #8b5cf6;
  --orange: #f59e0b;
  --red: #ef4444;
  
  /* Default accent */
  --accent-color: var(--blue);
  
  /* Font sizes */
  --font-size-small: 0.875rem;
  --font-size-medium: 1rem;
  --font-size-large: 1.125rem;
  
  /* Transitions */
  --transition-speed: 0.2s;
}

/* Dark theme */
.theme-dark {
  --background-primary: #121212;
  --background-secondary: #1e1e1e;
  --background-tertiary: #2d2d2d;
  --text-primary: #f5f5f5;
  --text-secondary: #b3b3b3;
  --text-tertiary: #888888;
  --border-color: #444444;
  --shadow-color: rgba(0, 0, 0, 0.3);
}

/* High contrast mode */
.high-contrast {
  --text-primary: #ffffff;
  --text-secondary: #eeeeee;
  --background-primary: #000000;
  --background-secondary: #121212;
  --background-tertiary: #1e1e1e;
  --border-color: #ffffff;
  --accent-color: #ffff00; /* Yellow for high visibility */
}

/* Font size variations */
.font-small {
  font-size: var(--font-size-small);
}

.font-medium {
  font-size: var(--font-size-medium);
}

.font-large {
  font-size: var(--font-size-large);
}

/* Apply variables to elements */
body {
  background-color: var(--background-primary);
  color: var(--text-primary);
  transition: background-color var(--transition-speed), color var(--transition-speed);
}

/* Component-specific theme styles */
.panel {
  background-color: var(--background-secondary);
  border: 1px solid var(--border-color);
  box-shadow: 0 2px 4px var(--shadow-color);
}

.button-primary {
  background-color: var(--accent-color);
  color: white;
}

.button-secondary {
  background-color: var(--background-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

/* Focus styles for accessibility */
:focus {
  outline: 2px solid var(--accent-color);
  outline-offset: 2px;
}

.high-contrast :focus {
  outline: 3px solid white;
}
```

### Theme Toggle Component
Create a component for toggling themes:

```typescript
const ThemeToggle: React.FC = () => {
  const { theme, setThemeMode } = useTheme();
  
  return (
    <div className="theme-toggle">
      <label htmlFor="theme-select">Theme</label>
      <select
        id="theme-select"
        value={theme.mode}
        onChange={(e) => setThemeMode(e.target.value as ThemeMode)}
        aria-label="Select theme mode"
      >
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="system">System</option>
      </select>
    </div>
  );
};
```

### Color Customization Component
Create a component for customizing accent colors:

```typescript
const AccentColorPicker: React.FC = () => {
  const { theme, setAccentColor, setCustomAccentColor } = useTheme();
  const [showCustomPicker, setShowCustomPicker] = useState(false);
  
  const handleColorChange = (color: string) => {
    setCustomAccentColor(color);
  };
  
  return (
    <div className="accent-color-picker">
      <h3>Accent Color</h3>
      
      <div className="color-options">
        <button
          className={`color-option blue ${theme.accentColor === 'blue' ? 'selected' : ''}`}
          onClick={() => setAccentColor('blue')}
          aria-label="Blue accent color"
        />
        <button
          className={`color-option green ${theme.accentColor === 'green' ? 'selected' : ''}`}
          onClick={() => setAccentColor('green')}
          aria-label="Green accent color"
        />
        <button
          className={`color-option purple ${theme.accentColor === 'purple' ? 'selected' : ''}`}
          onClick={() => setAccentColor('purple')}
          aria-label="Purple accent color"
        />
        <button
          className={`color-option orange ${theme.accentColor === 'orange' ? 'selected' : ''}`}
          onClick={() => setAccentColor('orange')}
          aria-label="Orange accent color"
        />
        <button
          className={`color-option red ${theme.accentColor === 'red' ? 'selected' : ''}`}
          onClick={() => setAccentColor('red')}
          aria-label="Red accent color"
        />
        <button
          className={`color-option custom ${theme.accentColor === 'custom' ? 'selected' : ''}`}
          onClick={() => {
            setAccentColor('custom');
            setShowCustomPicker(true);
          }}
          style={
            theme.accentColor === 'custom' && theme.customAccentColor
              ? { backgroundColor: theme.customAccentColor }
              : {}
          }
          aria-label="Custom accent color"
        >
          +
        </button>
      </div>
      
      {showCustomPicker && (
        <div className="custom-color-picker">
          <input
            type="color"
            value={theme.customAccentColor || '#2563eb'}
            onChange={(e) => handleColorChange(e.target.value)}
            aria-label="Select custom color"
          />
          <button
            onClick={() => setShowCustomPicker(false)}
            className="close-picker"
            aria-label="Close color picker"
          >
            Done
          </button>
        </div>
      )}
    </div>
  );
};
```

### Accessibility Settings Component
Create a component for accessibility settings:

```typescript
const AccessibilitySettings: React.FC = () => {
  const { theme, toggleHighContrast, setFontSize } = useTheme();
  
  return (
    <div className="accessibility-settings">
      <h3>Accessibility</h3>
      
      <div className="setting-group">
        <label htmlFor="high-contrast">
          <input
            id="high-contrast"
            type="checkbox"
            checked={theme.highContrast}
            onChange={toggleHighContrast}
          />
          High Contrast Mode
        </label>
      </div>
      
      <div className="setting-group">
        <label htmlFor="font-size">Font Size</label>
        <select
          id="font-size"
          value={theme.fontSize}
          onChange={(e) => setFontSize(e.target.value as any)}
          aria-label="Select font size"
        >
          <option value="small">Small</option>
          <option value="medium">Medium</option>
          <option value="large">Large</option>
        </select>
      </div>
    </div>
  );
};
```

### Settings Panel Component
Create a component for all appearance and accessibility settings:

```typescript
const AppearanceSettings: React.FC = () => {
  const { resetToDefaults } = useTheme();
  
  return (
    <div className="appearance-settings">
      <h2>Appearance & Accessibility</h2>
      
      <ThemeToggle />
      <AccentColorPicker />
      <AccessibilitySettings />
      
      <div className="settings-actions">
        <button
          onClick={resetToDefaults}
          className="reset-button"
          aria-label="Reset all appearance settings to defaults"
        >
          Reset to Defaults
        </button>
      </div>
    </div>
  );
};
```

### Keyboard Navigation System
Implement a keyboard shortcuts system:

```typescript
// Keyboard shortcut types
export interface KeyboardShortcut {
  id: string;
  keys: string[];
  description: string;
  action: () => void;
  category: 'navigation' | 'tools' | 'visualization' | 'data' | 'general';
}

// Keyboard context
interface KeyboardContextType {
  shortcuts: KeyboardShortcut[];
  registerShortcut: (shortcut: KeyboardShortcut) => void;
  unregisterShortcut: (id: string) => void;
  showShortcutsDialog: () => void;
}

const KeyboardContext = createContext<KeyboardContextType | undefined>(undefined);

// Keyboard provider component
export const KeyboardProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [shortcuts, setShortcuts] = useState<KeyboardShortcut[]>([]);
  const [showDialog, setShowDialog] = useState<boolean>(false);
  
  // Register a new shortcut
  const registerShortcut = useCallback((shortcut: KeyboardShortcut) => {
    setShortcuts(prev => {
      // Remove any existing shortcut with the same ID
      const filtered = prev.filter(s => s.id !== shortcut.id);
      return [...filtered, shortcut];
    });
  }, []);
  
  // Unregister a shortcut
  const unregisterShortcut = useCallback((id: string) => {
    setShortcuts(prev => prev.filter(s => s.id !== id));
  }, []);
  
  // Show shortcuts dialog
  const showShortcutsDialog = useCallback(() => {
    setShowDialog(true);
  }, []);
  
  // Handle keyboard events
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Skip if in an input field
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement ||
        e.target instanceof HTMLSelectElement
      ) {
        return;
      }
      
      // Check for help dialog shortcut (?)
      if (e.key === '?' && !e.ctrlKey && !e.altKey && !e.metaKey) {
        e.preventDefault();
        setShowDialog(true);
        return;
      }
      
      // Check for registered shortcuts
      for (const shortcut of shortcuts) {
        // Check if all keys in the shortcut are pressed
        const matchesShortcut = shortcut.keys.every(key => {
          if (key === 'Ctrl') return e.ctrlKey;
          if (key === 'Alt') return e.altKey;
          if (key === 'Shift') return e.shiftKey;
          if (key === 'Meta') return e.metaKey;
          return e.key === key;
        });
        
        if (matchesShortcut) {
          e.preventDefault();
          shortcut.action();
          return;
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [shortcuts]);
  
  // Create context value
  const contextValue = useMemo<KeyboardContextType>(() => ({
    shortcuts,
    registerShortcut,
    unregisterShortcut,
    showShortcutsDialog
  }), [shortcuts, registerShortcut, unregisterShortcut, showShortcutsDialog]);
  
  return (
    <KeyboardContext.Provider value={contextValue}>
      {children}
      {showDialog && (
        <KeyboardShortcutsDialog onClose={() => setShowDialog(false)} />
      )}
    </KeyboardContext.Provider>
  );
};

// Custom hook for using keyboard shortcuts
export const useKeyboard = (): KeyboardContextType => {
  const context = useContext(KeyboardContext);
  
  if (!context) {
    throw new Error('useKeyboard must be used within a KeyboardProvider');
  }
  
  return context;
};

// Keyboard shortcuts dialog component
const KeyboardShortcutsDialog: React.FC<{ onClose: () => void }> = ({ onClose }) => {
  const { shortcuts } = useKeyboard();
  
  // Group shortcuts by category
  const shortcutsByCategory = shortcuts.reduce<Record<string, KeyboardShortcut[]>>(
    (acc, shortcut) => {
      if (!acc[shortcut.category]) {
        acc[shortcut.category] = [];
      }
      acc[shortcut.category].push(shortcut);
      return acc;
    },
    {}
  );
  
  return (
    <div className="keyboard-shortcuts-dialog">
      <div className="dialog-header">
        <h2>Keyboard Shortcuts</h2>
        <button onClick={onClose} className="close-button" aria-label="Close dialog">
          Ã—
        </button>
      </div>
      
      <div className="dialog-content">
        {Object.entries(shortcutsByCategory).map(([category, shortcuts]) => (
          <div key={category} className="shortcut-category">
            <h3>{category.charAt(0).toUpperCase() + category.slice(1)}</h3>
            
            <table className="shortcuts-table">
              <tbody>
                {shortcuts.map(shortcut => (
                  <tr key={shortcut.id}>
                    <td className="shortcut-keys">
                      {shortcut.keys.map((key, index) => (
                        <React.Fragment key={key}>
                          <kbd>{key}</kbd>
                          {index < shortcut.keys.length - 1 && ' + '}
                        </React.Fragment>
                      ))}
                    </td>
                    <td className="shortcut-description">
                      {shortcut.description}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ))}
      </div>
      
      <div className="dialog-footer">
        <button onClick={onClose} className="close-button">
          Close
        </button>
      </div>
    </div>
  );
};
```

### Register Default Keyboard Shortcuts
Register default keyboard shortcuts in the application:

```typescript
const App: React.FC = () => {
  const { registerShortcut } = useKeyboard();
  const navigate = useNavigate();
  
  // Register default shortcuts
  useEffect(() => {
    // Navigation shortcuts
    registerShortcut({
      id: 'toggle-left-panel',
      keys: ['Alt', '['],
      description: 'Toggle left panel',
      action: () => {
        // Implementation
      },
      category: 'navigation'
    });
    
    registerShortcut({
      id: 'toggle-right-panel',
      keys: ['Alt', ']'],
      description: 'Toggle right panel',
      action: () => {
        // Implementation
      },
      category: 'navigation'
    });
    
    registerShortcut({
      id: 'toggle-bottom-panel',
      keys: ['Alt', '\\'],
      description: 'Toggle bottom panel',
      action: () => {
        // Implementation
      },
      category: 'navigation'
    });
    
    // Tool shortcuts
    registerShortcut({
      id: 'search',
      keys: ['Ctrl', 'f'],
      description: 'Search',
      action: () => {
        // Implementation
      },
      category: 'tools'
    });
    
    registerShortcut({
      id: 'export',
      keys: ['Ctrl', 'e'],
      description: 'Export data',
      action: () => {
        // Implementation
      },
      category: 'tools'
    });
    
    // Visualization shortcuts
    registerShortcut({
      id: 'zoom-in',
      keys: ['Ctrl', '='],
      description: 'Zoom in',
      action: () => {
        // Implementation
      },
      category: 'visualization'
    });
    
    registerShortcut({
      id: 'zoom-out',
      keys: ['Ctrl', '-'],
      description: 'Zoom out',
      action: () => {
        // Implementation
      },
      category: 'visualization'
    });
    
    registerShortcut({
      id: 'reset-view',
      keys: ['Ctrl', '0'],
      description: 'Reset view',
      action: () => {
        // Implementation
      },
      category: 'visualization'
    });
    
    // General shortcuts
    registerShortcut({
      id: 'settings',
      keys: ['Ctrl', ','],
      description: 'Open settings',
      action: () => {
        // Implementation
      },
      category: 'general'
    });
    
    registerShortcut({
      id: 'help',
      keys: ['F1'],
      description: 'Show help',
      action: () => {
        // Implementation
      },
      category: 'general'
    });
  }, [registerShortcut]);
  
  // Rest of the component
  return (
    <div className="app">
      {/* App content */}
    </div>
  );
};
```

### Focus Management
Implement focus management for keyboard navigation:

```typescript
// Focus trap component for modals and dialogs
const FocusTrap: React.FC<{
  children: React.ReactNode;
  active: boolean;
  onEscape?: () => void;
}> = ({ children, active, onEscape }) => {
  const trapRef = useRef<HTMLDivElement>(null);
  
  useEffect(() => {
    if (!active) return;
    
    const trapElement = trapRef.current;
    if (!trapElement) return;
    
    // Find all focusable elements
    const focusableElements = trapElement.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    // Focus the first element
    firstElement.focus();
    
    // Handle tab key to trap focus
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && onEscape) {
        e.preventDefault();
        onEscape();
        return;
      }
      
      if (e.key !== 'Tab') return;
      
      // Shift + Tab
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      }
      // Tab
      else {
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };
    
    trapElement.addEventListener('keydown', handleKeyDown);
    
    // Save previous active element
    const previousActiveElement = document.activeElement as HTMLElement;
    
    return () => {
      trapElement.removeEventListener('keydown', handleKeyDown);
      
      // Restore focus when unmounted
      if (previousActiveElement) {
        previousActiveElement.focus();
      }
    };
  }, [active, onEscape]);
  
  return (
    <div ref={trapRef} className="focus-trap">
      {children}
    </div>
  );
};
```

### Skip Link for Accessibility
Add a skip link for keyboard users:

```typescript
const SkipLink: React.FC = () => {
  return (
    <a
      href="#main-content"
      className="skip-link"
      tabIndex={0}
    >
      Skip to main content
    </a>
  );
};

// In the main App component
const App: React.FC = () => {
  return (
    <div className="app">
      <SkipLink />
      <Header />
      <main id="main-content">
        {/* Main content */}
      </main>
      <Footer />
    </div>
  );
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test theme and keyboard service functions
2. **Component Testing**: Test theme components and accessibility features
3. **Accessibility Testing**: Use tools like axe-core to test WCAG compliance

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used
Claude 3.7 Sonnet

### Debug Log References
N/A

### Completion Notes List
- Implemented theme context provider for managing theme preferences
- Created theme styles for light and dark modes
- Implemented high contrast mode for accessibility
- Added font size adjustment for better readability
- Created accent color customization with color picker
- Implemented theme toggle component
- Created appearance settings panel with theme and accessibility options
- Implemented keyboard shortcuts system with context provider
- Created keyboard shortcuts dialog for help
- Added focus trap component for modal accessibility
- Implemented skip link for keyboard navigation
- Added ARIA attributes to components for screen reader support
- Integrated all components into the application layout
- Implemented preference persistence using local storage

### File List
- app/contexts/ThemeContext.tsx (new)
- app/styles/themes.css (new)
- app/components/theme/ThemeToggle.tsx (new)
- app/components/theme/AccentColorPicker.tsx (new)
- app/components/theme/AccessibilitySettings.tsx (new)
- app/components/theme/AppearanceSettings.tsx (new)
- app/contexts/KeyboardContext.tsx (new)
- app/components/accessibility/KeyboardShortcutsDialog.tsx (new)
- app/components/accessibility/FocusTrap.tsx (new)
- app/components/accessibility/SkipLink.tsx (new)
- app/components/keyboard/KeyboardShortcutsSetup.tsx (new)
- app/components/layout/MainLayout.tsx (modified)
- app/components/layout/AppHeader.tsx (modified)
- app/page.tsx (modified)
- app/globals.css (modified)

## QA Results
