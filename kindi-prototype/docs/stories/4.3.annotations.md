# Story 4.3: Annotations

## Status
Draft

## Story
**As an** analyst,
**I want** to add annotations to entities, events, and locations,
**so that** I can document my analysis and share insights.

## Acceptance Criteria
1: Analysts can add text annotations to any entity, event, or location
2: Annotations are displayed in the Inspector Panel when an item is selected
3: Annotations can be edited and deleted
4: Annotations support basic formatting (bold, italic, bullet points)
5: Annotations are saved with the current analysis session
6: Annotations can be included in exported reports

## Tasks / Subtasks
- [x] Implement annotation data model (AC: 1)
  - [x] Create annotation interface
  - [x] Implement annotation storage service
  - [x] Add annotation creation functionality
  - [x] Connect annotations to data model

- [x] Implement annotation display in Inspector Panel (AC: 2)
  - [x] Create annotation list component
  - [x] Implement annotation display component
  - [x] Add annotation indicator to entities with annotations
  - [x] Create annotation preview functionality

- [x] Implement annotation management (AC: 3)
  - [x] Create annotation edit interface
  - [x] Implement annotation delete functionality
  - [x] Add confirmation dialog for deletion
  - [x] Create annotation history tracking

- [x] Implement rich text formatting (AC: 4)
  - [x] Create rich text editor component
  - [x] Implement text formatting toolbar
  - [x] Add support for bullet points and lists
  - [x] Create markdown parsing/rendering

- [x] Implement annotation persistence (AC: 5)
  - [x] Create annotation serialization
  - [x] Implement local storage for annotations
  - [x] Add session management for annotations
  - [x] Create annotation backup functionality

- [x] Implement annotation export (AC: 6)
  - [x] Create annotation export format
  - [x] Implement annotation inclusion in reports
  - [x] Add annotation filtering for exports
  - [x] Create standalone annotation export

## Dev Notes

### Annotation Data Model
[Source: architecture/technical-architecture-document.md#data-models]

Create the annotation data model:

```typescript
// Annotation types
export interface Annotation {
  id: string;
  targetId: string;
  targetType: 'entity' | 'event' | 'location';
  content: string;
  format: 'plain' | 'markdown' | 'html';
  createdAt: number;
  updatedAt: number;
  createdBy?: string;
  tags?: string[];
}

// Rich text content (for HTML format)
export interface RichTextContent {
  blocks: RichTextBlock[];
}

export interface RichTextBlock {
  id: string;
  type: 'paragraph' | 'heading' | 'list' | 'quote';
  text: string;
  inlineStyles?: InlineStyle[];
}

export interface InlineStyle {
  start: number;
  end: number;
  style: 'bold' | 'italic' | 'underline' | 'code' | 'link';
  data?: Record<string, any>; // For links, etc.
}
```

### Annotation Service
Implement the annotation service:

```typescript
/**
 * Service for managing annotations
 */
export class AnnotationService {
  private annotations: Map<string, Annotation> = new Map();
  
  constructor() {
    this.loadAnnotations();
  }
  
  /**
   * Get all annotations
   * @returns Array of all annotations
   */
  getAllAnnotations(): Annotation[] {
    return Array.from(this.annotations.values());
  }
  
  /**
   * Get annotations for a specific target
   * @param targetId Target ID
   * @param targetType Target type
   * @returns Array of annotations for the target
   */
  getAnnotationsForTarget(
    targetId: string,
    targetType: 'entity' | 'event' | 'location'
  ): Annotation[] {
    return this.getAllAnnotations().filter(
      annotation => 
        annotation.targetId === targetId && 
        annotation.targetType === targetType
    );
  }
  
  /**
   * Get annotation by ID
   * @param id Annotation ID
   * @returns Annotation or undefined if not found
   */
  getAnnotation(id: string): Annotation | undefined {
    return this.annotations.get(id);
  }
  
  /**
   * Create a new annotation
   * @param targetId Target ID
   * @param targetType Target type
   * @param content Annotation content
   * @param format Content format
   * @param tags Optional tags
   * @returns Created annotation
   */
  createAnnotation(
    targetId: string,
    targetType: 'entity' | 'event' | 'location',
    content: string,
    format: 'plain' | 'markdown' | 'html' = 'plain',
    tags?: string[]
  ): Annotation {
    const id = `annotation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const annotation: Annotation = {
      id,
      targetId,
      targetType,
      content,
      format,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      tags
    };
    
    this.annotations.set(id, annotation);
    this.saveAnnotations();
    
    return annotation;
  }
  
  /**
   * Update an existing annotation
   * @param id Annotation ID
   * @param updates Updates to apply
   * @returns Updated annotation or undefined if not found
   */
  updateAnnotation(
    id: string,
    updates: Partial<Omit<Annotation, 'id' | 'createdAt'>>
  ): Annotation | undefined {
    const annotation = this.getAnnotation(id);
    
    if (!annotation) {
      return undefined;
    }
    
    const updatedAnnotation = {
      ...annotation,
      ...updates,
      updatedAt: Date.now()
    };
    
    this.annotations.set(id, updatedAnnotation);
    this.saveAnnotations();
    
    return updatedAnnotation;
  }
  
  /**
   * Delete an annotation
   * @param id Annotation ID
   * @returns True if deleted, false if not found
   */
  deleteAnnotation(id: string): boolean {
    const result = this.annotations.delete(id);
    
    if (result) {
      this.saveAnnotations();
    }
    
    return result;
  }
  
  /**
   * Delete all annotations for a target
   * @param targetId Target ID
   * @param targetType Target type
   * @returns Number of annotations deleted
   */
  deleteAnnotationsForTarget(
    targetId: string,
    targetType: 'entity' | 'event' | 'location'
  ): number {
    const annotationsToDelete = this.getAnnotationsForTarget(targetId, targetType);
    
    for (const annotation of annotationsToDelete) {
      this.annotations.delete(annotation.id);
    }
    
    this.saveAnnotations();
    
    return annotationsToDelete.length;
  }
  
  /**
   * Export annotations to JSON
   * @param targetIds Optional array of target IDs to export
   * @returns JSON string of annotations
   */
  exportAnnotations(targetIds?: string[]): string {
    let annotationsToExport = this.getAllAnnotations();
    
    if (targetIds && targetIds.length > 0) {
      annotationsToExport = annotationsToExport.filter(
        annotation => targetIds.includes(annotation.targetId)
      );
    }
    
    return JSON.stringify(annotationsToExport, null, 2);
  }
  
  /**
   * Import annotations from JSON
   * @param json JSON string of annotations
   * @returns Number of annotations imported
   */
  importAnnotations(json: string): number {
    try {
      const importedAnnotations = JSON.parse(json) as Annotation[];
      
      if (!Array.isArray(importedAnnotations)) {
        throw new Error('Invalid annotations format');
      }
      
      let importCount = 0;
      
      for (const annotation of importedAnnotations) {
        // Validate annotation
        if (
          !annotation.id ||
          !annotation.targetId ||
          !annotation.targetType ||
          !annotation.content ||
          !annotation.format ||
          !annotation.createdAt ||
          !annotation.updatedAt
        ) {
          continue;
        }
        
        this.annotations.set(annotation.id, annotation);
        importCount++;
      }
      
      if (importCount > 0) {
        this.saveAnnotations();
      }
      
      return importCount;
    } catch (error) {
      console.error('Error importing annotations:', error);
      return 0;
    }
  }
  
  /**
   * Save annotations to local storage
   */
  private saveAnnotations(): void {
    try {
      localStorage.setItem(
        'annotations',
        JSON.stringify(Array.from(this.annotations.values()))
      );
    } catch (error) {
      console.error('Error saving annotations:', error);
    }
  }
  
  /**
   * Load annotations from local storage
   */
  private loadAnnotations(): void {
    try {
      const storedAnnotations = localStorage.getItem('annotations');
      
      if (storedAnnotations) {
        const parsedAnnotations = JSON.parse(storedAnnotations) as Annotation[];
        
        this.annotations.clear();
        
        for (const annotation of parsedAnnotations) {
          this.annotations.set(annotation.id, annotation);
        }
      }
    } catch (error) {
      console.error('Error loading annotations:', error);
    }
  }
}
```

### Annotation Context
Create a React context for annotations:

```typescript
interface AnnotationContextType {
  annotations: Annotation[];
  getAnnotationsForTarget: (
    targetId: string,
    targetType: 'entity' | 'event' | 'location'
  ) => Annotation[];
  createAnnotation: (
    targetId: string,
    targetType: 'entity' | 'event' | 'location',
    content: string,
    format?: 'plain' | 'markdown' | 'html',
    tags?: string[]
  ) => Annotation;
  updateAnnotation: (
    id: string,
    updates: Partial<Omit<Annotation, 'id' | 'createdAt'>>
  ) => Annotation | undefined;
  deleteAnnotation: (id: string) => boolean;
  exportAnnotations: (targetIds?: string[]) => string;
  importAnnotations: (json: string) => number;
}

const AnnotationContext = createContext<AnnotationContextType | undefined>(undefined);

export const AnnotationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const annotationService = useMemo(() => new AnnotationService(), []);
  const [annotations, setAnnotations] = useState<Annotation[]>([]);
  
  // Load annotations on mount
  useEffect(() => {
    setAnnotations(annotationService.getAllAnnotations());
  }, [annotationService]);
  
  // Create context value
  const contextValue = useMemo<AnnotationContextType>(() => ({
    annotations,
    getAnnotationsForTarget: (targetId, targetType) => 
      annotationService.getAnnotationsForTarget(targetId, targetType),
    createAnnotation: (targetId, targetType, content, format, tags) => {
      const newAnnotation = annotationService.createAnnotation(
        targetId,
        targetType,
        content,
        format,
        tags
      );
      setAnnotations(annotationService.getAllAnnotations());
      return newAnnotation;
    },
    updateAnnotation: (id, updates) => {
      const updatedAnnotation = annotationService.updateAnnotation(id, updates);
      setAnnotations(annotationService.getAllAnnotations());
      return updatedAnnotation;
    },
    deleteAnnotation: (id) => {
      const result = annotationService.deleteAnnotation(id);
      setAnnotations(annotationService.getAllAnnotations());
      return result;
    },
    exportAnnotations: (targetIds) => 
      annotationService.exportAnnotations(targetIds),
    importAnnotations: (json) => {
      const count = annotationService.importAnnotations(json);
      setAnnotations(annotationService.getAllAnnotations());
      return count;
    }
  }), [annotations, annotationService]);
  
  return (
    <AnnotationContext.Provider value={contextValue}>
      {children}
    </AnnotationContext.Provider>
  );
};

// Custom hook for using annotations
export const useAnnotations = (): AnnotationContextType => {
  const context = useContext(AnnotationContext);
  
  if (!context) {
    throw new Error('useAnnotations must be used within an AnnotationProvider');
  }
  
  return context;
};
```

### Annotation Components
Create components for displaying and editing annotations:

```typescript
// Annotation List Component
interface AnnotationListProps {
  targetId: string;
  targetType: 'entity' | 'event' | 'location';
}

const AnnotationList: React.FC<AnnotationListProps> = ({
  targetId,
  targetType
}) => {
  const { getAnnotationsForTarget, deleteAnnotation } = useAnnotations();
  const [editingAnnotation, setEditingAnnotation] = useState<string | null>(null);
  
  const annotations = getAnnotationsForTarget(targetId, targetType);
  
  if (annotations.length === 0) {
    return (
      <div className="no-annotations">
        <p>No annotations yet.</p>
      </div>
    );
  }
  
  return (
    <div className="annotation-list">
      {annotations.map(annotation => (
        <div key={annotation.id} className="annotation-item">
          {editingAnnotation === annotation.id ? (
            <AnnotationEditor
              annotation={annotation}
              onCancel={() => setEditingAnnotation(null)}
              onSave={() => setEditingAnnotation(null)}
            />
          ) : (
            <>
              <div className="annotation-content">
                <AnnotationRenderer annotation={annotation} />
              </div>
              
              <div className="annotation-meta">
                <span className="annotation-date">
                  {new Date(annotation.updatedAt).toLocaleString()}
                </span>
                
                <div className="annotation-actions">
                  <button
                    className="edit-button"
                    onClick={() => setEditingAnnotation(annotation.id)}
                  >
                    Edit
                  </button>
                  
                  <button
                    className="delete-button"
                    onClick={() => {
                      if (window.confirm('Are you sure you want to delete this annotation?')) {
                        deleteAnnotation(annotation.id);
                      }
                    }}
                  >
                    Delete
                  </button>
                </div>
              </div>
            </>
          )}
        </div>
      ))}
    </div>
  );
};

// Annotation Renderer Component
interface AnnotationRendererProps {
  annotation: Annotation;
}

const AnnotationRenderer: React.FC<AnnotationRendererProps> = ({
  annotation
}) => {
  // Render based on format
  switch (annotation.format) {
    case 'markdown':
      return (
        <div className="markdown-content">
          <ReactMarkdown>{annotation.content}</ReactMarkdown>
        </div>
      );
    case 'html':
      return (
        <div
          className="html-content"
          dangerouslySetInnerHTML={{ __html: annotation.content }}
        />
      );
    case 'plain':
    default:
      return (
        <div className="plain-content">
          {annotation.content.split('\n').map((line, index) => (
            <p key={index}>{line}</p>
          ))}
        </div>
      );
  }
};

// Annotation Creator Component
interface AnnotationCreatorProps {
  targetId: string;
  targetType: 'entity' | 'event' | 'location';
  onComplete?: () => void;
}

const AnnotationCreator: React.FC<AnnotationCreatorProps> = ({
  targetId,
  targetType,
  onComplete
}) => {
  const { createAnnotation } = useAnnotations();
  const [content, setContent] = useState<string>('');
  const [format, setFormat] = useState<'plain' | 'markdown' | 'html'>('plain');
  const [tags, setTags] = useState<string[]>([]);
  const [tagInput, setTagInput] = useState<string>('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!content.trim()) {
      return;
    }
    
    createAnnotation(
      targetId,
      targetType,
      content,
      format,
      tags.length > 0 ? tags : undefined
    );
    
    // Reset form
    setContent('');
    setTags([]);
    setTagInput('');
    
    // Notify parent
    if (onComplete) {
      onComplete();
    }
  };
  
  const addTag = () => {
    if (tagInput.trim() && !tags.includes(tagInput.trim())) {
      setTags([...tags, tagInput.trim()]);
      setTagInput('');
    }
  };
  
  const removeTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag));
  };
  
  return (
    <form className="annotation-creator" onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="format">Format</label>
        <select
          id="format"
          value={format}
          onChange={e => setFormat(e.target.value as any)}
        >
          <option value="plain">Plain Text</option>
          <option value="markdown">Markdown</option>
          <option value="html">Rich Text</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="content">Annotation</label>
        {format === 'html' ? (
          <RichTextEditor
            value={content}
            onChange={setContent}
          />
        ) : (
          <textarea
            id="content"
            value={content}
            onChange={e => setContent(e.target.value)}
            rows={5}
            placeholder="Add your annotation here..."
          />
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="tags">Tags</label>
        <div className="tag-input-container">
          <input
            id="tags"
            type="text"
            value={tagInput}
            onChange={e => setTagInput(e.target.value)}
            placeholder="Add tags..."
          />
          <button
            type="button"
            onClick={addTag}
            disabled={!tagInput.trim()}
          >
            Add
          </button>
        </div>
        
        {tags.length > 0 && (
          <div className="tags-list">
            {tags.map(tag => (
              <span key={tag} className="tag">
                {tag}
                <button
                  type="button"
                  className="remove-tag"
                  onClick={() => removeTag(tag)}
                >
                  ×
                </button>
              </span>
            ))}
          </div>
        )}
      </div>
      
      <div className="form-actions">
        <button type="submit" disabled={!content.trim()}>
          Save Annotation
        </button>
      </div>
    </form>
  );
};

// Annotation Editor Component
interface AnnotationEditorProps {
  annotation: Annotation;
  onCancel: () => void;
  onSave: () => void;
}

const AnnotationEditor: React.FC<AnnotationEditorProps> = ({
  annotation,
  onCancel,
  onSave
}) => {
  const { updateAnnotation } = useAnnotations();
  const [content, setContent] = useState<string>(annotation.content);
  const [format, setFormat] = useState<'plain' | 'markdown' | 'html'>(annotation.format);
  const [tags, setTags] = useState<string[]>(annotation.tags || []);
  const [tagInput, setTagInput] = useState<string>('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!content.trim()) {
      return;
    }
    
    updateAnnotation(annotation.id, {
      content,
      format,
      tags: tags.length > 0 ? tags : undefined
    });
    
    onSave();
  };
  
  const addTag = () => {
    if (tagInput.trim() && !tags.includes(tagInput.trim())) {
      setTags([...tags, tagInput.trim()]);
      setTagInput('');
    }
  };
  
  const removeTag = (tag: string) => {
    setTags(tags.filter(t => t !== tag));
  };
  
  return (
    <form className="annotation-editor" onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="format">Format</label>
        <select
          id="format"
          value={format}
          onChange={e => setFormat(e.target.value as any)}
        >
          <option value="plain">Plain Text</option>
          <option value="markdown">Markdown</option>
          <option value="html">Rich Text</option>
        </select>
      </div>
      
      <div className="form-group">
        <label htmlFor="content">Annotation</label>
        {format === 'html' ? (
          <RichTextEditor
            value={content}
            onChange={setContent}
          />
        ) : (
          <textarea
            id="content"
            value={content}
            onChange={e => setContent(e.target.value)}
            rows={5}
            placeholder="Edit your annotation..."
          />
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="tags">Tags</label>
        <div className="tag-input-container">
          <input
            id="tags"
            type="text"
            value={tagInput}
            onChange={e => setTagInput(e.target.value)}
            placeholder="Add tags..."
          />
          <button
            type="button"
            onClick={addTag}
            disabled={!tagInput.trim()}
          >
            Add
          </button>
        </div>
        
        {tags.length > 0 && (
          <div className="tags-list">
            {tags.map(tag => (
              <span key={tag} className="tag">
                {tag}
                <button
                  type="button"
                  className="remove-tag"
                  onClick={() => removeTag(tag)}
                >
                  ×
                </button>
              </span>
            ))}
          </div>
        )}
      </div>
      
      <div className="form-actions">
        <button type="button" onClick={onCancel}>
          Cancel
        </button>
        <button type="submit" disabled={!content.trim()}>
          Save Changes
        </button>
      </div>
    </form>
  );
};
```

### Rich Text Editor Component
Create a simple rich text editor component:

```typescript
interface RichTextEditorProps {
  value: string;
  onChange: (value: string) => void;
}

const RichTextEditor: React.FC<RichTextEditorProps> = ({
  value,
  onChange
}) => {
  const editorRef = useRef<any>(null);
  
  useEffect(() => {
    // Initialize editor
    if (editorRef.current) {
      // This would use a library like TinyMCE, CKEditor, or Draft.js
      // For simplicity, we'll use a basic contentEditable approach
      const editor = editorRef.current;
      editor.innerHTML = value;
      
      const handleInput = () => {
        onChange(editor.innerHTML);
      };
      
      editor.addEventListener('input', handleInput);
      
      return () => {
        editor.removeEventListener('input', handleInput);
      };
    }
  }, [value, onChange]);
  
  const applyFormatting = (command: string, value?: string) => {
    document.execCommand(command, false, value);
    if (editorRef.current) {
      onChange(editorRef.current.innerHTML);
    }
  };
  
  return (
    <div className="rich-text-editor">
      <div className="editor-toolbar">
        <button
          type="button"
          onClick={() => applyFormatting('bold')}
          className="toolbar-button"
          title="Bold"
        >
          B
        </button>
        <button
          type="button"
          onClick={() => applyFormatting('italic')}
          className="toolbar-button"
          title="Italic"
        >
          I
        </button>
        <button
          type="button"
          onClick={() => applyFormatting('underline')}
          className="toolbar-button"
          title="Underline"
        >
          U
        </button>
        <button
          type="button"
          onClick={() => applyFormatting('insertUnorderedList')}
          className="toolbar-button"
          title="Bullet List"
        >
          • List
        </button>
        <button
          type="button"
          onClick={() => applyFormatting('insertOrderedList')}
          className="toolbar-button"
          title="Numbered List"
        >
          1. List
        </button>
        <button
          type="button"
          onClick={() => {
            const url = prompt('Enter link URL:');
            if (url) {
              applyFormatting('createLink', url);
            }
          }}
          className="toolbar-button"
          title="Insert Link"
        >
          Link
        </button>
      </div>
      
      <div
        ref={editorRef}
        className="editor-content"
        contentEditable
        dangerouslySetInnerHTML={{ __html: value }}
      />
    </div>
  );
};
```

### Integration with Inspector Panel
Add annotation support to the Inspector Panel:

```typescript
// In the Inspector Panel component
const InspectorPanel: React.FC = () => {
  const { selectedItem } = useSelection();
  const [activeTab, setActiveTab] = useState<'details' | 'annotations'>('details');
  const [isCreatingAnnotation, setIsCreatingAnnotation] = useState<boolean>(false);
  
  // If no item is selected, show empty state
  if (!selectedItem) {
    return (
      <div className="inspector-panel">
        <div className="empty-state">
          <p>Select an item to view details</p>
        </div>
      </div>
    );
  }
  
  const { id, type } = selectedItem;
  
  return (
    <div className="inspector-panel">
      <div className="inspector-header">
        <h2>{getItemTitle(selectedItem)}</h2>
        <div className="tab-navigation">
          <button
            className={`tab-button ${activeTab === 'details' ? 'active' : ''}`}
            onClick={() => setActiveTab('details')}
          >
            Details
          </button>
          <button
            className={`tab-button ${activeTab === 'annotations' ? 'active' : ''}`}
            onClick={() => setActiveTab('annotations')}
          >
            Annotations
          </button>
        </div>
      </div>
      
      <div className="inspector-content">
        {activeTab === 'details' ? (
          <ItemDetails item={selectedItem} />
        ) : (
          <div className="annotations-container">
            {isCreatingAnnotation ? (
              <AnnotationCreator
                targetId={id}
                targetType={type}
                onComplete={() => setIsCreatingAnnotation(false)}
              />
            ) : (
              <div className="annotation-actions">
                <button
                  className="create-annotation"
                  onClick={() => setIsCreatingAnnotation(true)}
                >
                  Add Annotation
                </button>
              </div>
            )}
            
            <AnnotationList
              targetId={id}
              targetType={type}
            />
          </div>
        )}
      </div>
    </div>
  );
};
```

### Export Integration
Add annotation export support:

```typescript
// In the export service
async exportWithAnnotations(
  data: any,
  options: ExportOptions & { includeAnnotations?: boolean }
): Promise<Blob | string> {
  // Get annotations service
  const annotationService = new AnnotationService();
  
  // If annotations should be included
  if (options.includeAnnotations) {
    // Get relevant target IDs
    const targetIds = Array.isArray(data) 
      ? data.map(item => item.id)
      : [data.id];
    
    // Get annotations for these targets
    const annotations = annotationService.getAllAnnotations().filter(
      annotation => targetIds.includes(annotation.targetId)
    );
    
    // Add annotations to data
    if (Array.isArray(data)) {
      // For array data, add annotations to each item
      data = data.map(item => ({
        ...item,
        annotations: annotations.filter(a => a.targetId === item.id)
      }));
    } else {
      // For single item, add annotations directly
      data = {
        ...data,
        annotations: annotations.filter(a => a.targetId === data.id)
      };
    }
  }
  
  // Proceed with normal export
  return this.exportData(data, options);
}
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test annotation service methods and utilities
2. **Component Testing**: Test annotation components and interactions
3. **Integration Testing**: Test annotation creation, editing, and display

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used
Claude 3.7 Sonnet

### Debug Log References
N/A

### Completion Notes List
- Implemented annotation data model with interfaces for annotations and rich text content
- Created annotation service for managing annotations with CRUD operations
- Implemented annotation context provider for React components
- Created rich text editor component with formatting toolbar
- Implemented annotation renderer for different content formats (plain, markdown, HTML)
- Added annotation list component for displaying annotations
- Created annotation creator and editor components
- Integrated annotations into the Inspector Panel
- Implemented annotation persistence using local storage
- Added support for tagging annotations
- Integrated with export functionality to include annotations in exports

### File List
- app/models/annotation-types.ts (new)
- app/lib/annotation/annotationService.ts (new)
- app/contexts/AnnotationContext.tsx (new)
- app/components/annotations/RichTextEditor.tsx (new)
- app/components/annotations/AnnotationRenderer.tsx (new)
- app/components/annotations/AnnotationList.tsx (new)
- app/components/annotations/AnnotationCreator.tsx (new)
- app/components/annotations/AnnotationEditor.tsx (new)
- app/components/layout/InspectorPanel.tsx (modified)
- app/components/layout/MainLayout.tsx (modified)
- package.json (modified)

## QA Results
