# Story 2.4: Data Transformation Utilities

## Status
Draft

## Story
**As a** developer,
**I want** to create utilities for transforming and filtering data,
**so that** the visualization components can efficiently access the data they need.

## Acceptance Criteria
1: Utilities for filtering data by entity type are implemented
2: Utilities for filtering data by time range are implemented
3: Utilities for filtering data by geographic region are implemented
4: Data transformation functions optimize data for each visualization type
5: Utilities include performance optimizations for large datasets
6: Functions are well-documented and unit tested

## Tasks / Subtasks
- [ ] Implement entity type filtering (AC: 1)
  - [ ] Create utility function to filter entities by type
  - [ ] Implement filtering for relationships based on entity types
  - [ ] Add support for multiple entity type selection
  - [ ] Create helper functions for common entity type groups

- [ ] Implement time range filtering (AC: 2)
  - [ ] Create utility function to filter events by time range
  - [ ] Implement filtering for relationships with time attributes
  - [ ] Add support for relative time ranges (last 7 days, last month, etc.)
  - [ ] Create utility for time aggregation (day, week, month)

- [ ] Implement geographic filtering (AC: 3)
  - [ ] Create utility function to filter locations by region
  - [ ] Implement bounding box and radius filtering
  - [ ] Add support for custom polygon region filtering
  - [ ] Create utility for geographic clustering

- [ ] Create visualization-specific transformers (AC: 4)
  - [ ] Implement graph data transformer for react-force-graph
  - [ ] Create timeline item transformer for vis-timeline
  - [ ] Build map marker transformer for react-leaflet
  - [ ] Develop unified data access layer for all visualizations

- [ ] Implement performance optimizations (AC: 5)
  - [ ] Create indexing utilities for fast data lookups
  - [ ] Implement data chunking for large datasets
  - [ ] Add memoization for expensive transformations
  - [ ] Create worker-based processing for heavy operations

- [ ] Create documentation and tests (AC: 6)
  - [ ] Add JSDoc comments for all utility functions
  - [ ] Create TypeScript interfaces for all data structures
  - [ ] Write unit tests for all utility functions
  - [ ] Add performance benchmarks for optimization verification

## Dev Notes

### Data Architecture
[Source: architecture/technical-architecture-document.md#data-architecture]

The data transformation utilities should be implemented in the lib/data directory:

```
app/
└── lib/
    └── data/
        ├── filters/            # Data filtering utilities
        │   ├── entityFilters.ts
        │   ├── timeFilters.ts
        │   └── geoFilters.ts
        ├── transformers/       # Visualization-specific transformers
        │   ├── graphTransformer.ts
        │   ├── timelineTransformer.ts
        │   └── mapTransformer.ts
        ├── indexing/           # Data indexing for performance
        │   ├── entityIndex.ts
        │   ├── relationshipIndex.ts
        │   └── spatialIndex.ts
        └── utils/              # Common utility functions
            ├── dataAccess.ts
            └── optimization.ts
```

### Entity Type Filtering
[Source: architecture/technical-architecture-document.md#data-models]

Implement entity filtering utilities:

```typescript
/**
 * Filters entities by type
 * @param entities Array of entities to filter
 * @param types Array of entity types to include
 * @returns Filtered array of entities
 */
export const filterEntitiesByType = (
  entities: Entity[],
  types: EntityType[]
): Entity[] => {
  if (!types.length) return entities;
  return entities.filter(entity => types.includes(entity.type));
};

/**
 * Filters relationships based on connected entity types
 * @param relationships Array of relationships to filter
 * @param entities Array of entities
 * @param sourceTypes Types to match for source entities
 * @param targetTypes Types to match for target entities
 * @returns Filtered array of relationships
 */
export const filterRelationshipsByEntityTypes = (
  relationships: Relationship[],
  entities: Entity[],
  sourceTypes: EntityType[] = [],
  targetTypes: EntityType[] = []
): Relationship[] => {
  if (!sourceTypes.length && !targetTypes.length) return relationships;
  
  // Create entity lookup map for performance
  const entityMap = new Map(entities.map(entity => [entity.id, entity]));
  
  return relationships.filter(rel => {
    const sourceEntity = entityMap.get(rel.source);
    const targetEntity = entityMap.get(rel.target);
    
    const sourceTypeMatch = !sourceTypes.length || 
      (sourceEntity && sourceTypes.includes(sourceEntity.type));
    const targetTypeMatch = !targetTypes.length || 
      (targetEntity && targetTypes.includes(targetEntity.type));
    
    return sourceTypeMatch && targetTypeMatch;
  });
};
```

### Time Range Filtering
[Source: architecture/technical-architecture-document.md#data-models]

Implement time filtering utilities:

```typescript
/**
 * Filters events by time range
 * @param events Array of events to filter
 * @param startTime Start of time range (ISO string or Date)
 * @param endTime End of time range (ISO string or Date)
 * @returns Filtered array of events
 */
export const filterEventsByTimeRange = (
  events: Event[],
  startTime?: string | Date,
  endTime?: string | Date
): Event[] => {
  if (!startTime && !endTime) return events;
  
  const start = startTime ? new Date(startTime).getTime() : 0;
  const end = endTime ? new Date(endTime).getTime() : Infinity;
  
  return events.filter(event => {
    const eventTime = new Date(event.time).getTime();
    return eventTime >= start && eventTime <= end;
  });
};

/**
 * Creates a relative time range
 * @param unit Time unit (day, week, month, year)
 * @param amount Number of units
 * @returns Object with start and end dates
 */
export const createRelativeTimeRange = (
  unit: 'day' | 'week' | 'month' | 'year',
  amount: number
): { startTime: Date, endTime: Date } => {
  const end = new Date();
  const start = new Date();
  
  switch (unit) {
    case 'day':
      start.setDate(start.getDate() - amount);
      break;
    case 'week':
      start.setDate(start.getDate() - (amount * 7));
      break;
    case 'month':
      start.setMonth(start.getMonth() - amount);
      break;
    case 'year':
      start.setFullYear(start.getFullYear() - amount);
      break;
  }
  
  return { startTime: start, endTime: end };
};
```

### Geographic Filtering
[Source: architecture/technical-architecture-document.md#data-models]

Implement geographic filtering utilities:

```typescript
/**
 * Filters locations by bounding box
 * @param locations Array of locations to filter
 * @param bounds Bounding box coordinates
 * @returns Filtered array of locations
 */
export const filterLocationsByBounds = (
  locations: GeoLocation[],
  bounds: {
    north: number;
    south: number;
    east: number;
    west: number;
  }
): GeoLocation[] => {
  return locations.filter(location => {
    return location.latitude <= bounds.north &&
           location.latitude >= bounds.south &&
           location.longitude <= bounds.east &&
           location.longitude >= bounds.west;
  });
};

/**
 * Filters locations by radius
 * @param locations Array of locations to filter
 * @param center Center point coordinates
 * @param radiusKm Radius in kilometers
 * @returns Filtered array of locations
 */
export const filterLocationsByRadius = (
  locations: GeoLocation[],
  center: { latitude: number; longitude: number },
  radiusKm: number
): GeoLocation[] => {
  return locations.filter(location => {
    return calculateDistance(
      center.latitude,
      center.longitude,
      location.latitude,
      location.longitude
    ) <= radiusKm;
  });
};

/**
 * Calculate distance between two points using Haversine formula
 * @param lat1 Latitude of first point
 * @param lon1 Longitude of first point
 * @param lat2 Latitude of second point
 * @param lon2 Longitude of second point
 * @returns Distance in kilometers
 */
const calculateDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const R = 6371; // Earth's radius in km
  const dLat = toRadians(lat2 - lat1);
  const dLon = toRadians(lon2 - lon1);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
};

const toRadians = (degrees: number): number => {
  return degrees * (Math.PI / 180);
};
```

### Visualization-Specific Transformers
[Source: architecture/technical-architecture-document.md#visualization-libraries]

Implement data transformers for each visualization:

```typescript
// Graph transformer
export const transformForGraph = (
  entities: Entity[],
  relationships: Relationship[]
): GraphData => {
  return {
    nodes: entities.map(entity => ({
      id: entity.id,
      name: entity.name,
      type: entity.type,
      val: entity.risk || 1,
      color: getColorForEntityType(entity.type),
      attributes: entity.attributes,
      metadata: entity.metadata
    })),
    links: relationships.map(rel => ({
      source: rel.source,
      target: rel.target,
      type: rel.type,
      directed: rel.directed,
      strength: rel.strength || 1,
      attributes: rel.attributes
    }))
  };
};

// Timeline transformer
export const transformForTimeline = (
  events: Event[]
): TimelineData => {
  return {
    items: events.map(event => ({
      id: event.id,
      content: event.title,
      title: event.description || event.title,
      start: new Date(event.time),
      end: event.endTime ? new Date(event.endTime) : undefined,
      group: event.type,
      className: `event-type-${event.type}`,
      itemProps: {
        entities: event.entities,
        location: event.location,
        attributes: event.attributes
      }
    })),
    groups: Array.from(new Set(events.map(event => event.type)))
      .map((type, index) => ({
        id: type,
        content: getEventTypeLabel(type),
        className: `group-type-${type}`
      }))
  };
};

// Map transformer
export const transformForMap = (
  locations: GeoLocation[],
  entities: Entity[]
): MapData => {
  return {
    markers: locations.map(location => {
      const relatedEntities = entities.filter(entity => 
        entity.attributes?.locationId === location.id
      );
      
      return {
        id: location.id,
        position: [location.latitude, location.longitude],
        name: location.name || 'Unnamed Location',
        type: location.type || 'CUSTOM',
        address: location.address,
        entities: relatedEntities.map(e => e.id),
        primaryEntityType: relatedEntities[0]?.type || 'LOCATION',
        attributes: location.attributes
      };
    })
  };
};
```

### Performance Optimizations
[Source: architecture/technical-architecture-document.md#performance-optimization]

Implement performance optimization utilities:

```typescript
/**
 * Creates indexes for fast entity lookups
 * @param entities Array of entities to index
 * @returns Object with various indexes
 */
export const createEntityIndexes = (entities: Entity[]) => {
  // Index by ID for O(1) lookups
  const byId = new Map(entities.map(entity => [entity.id, entity]));
  
  // Index by type for filtered lookups
  const byType = new Map<EntityType, Entity[]>();
  for (const entity of entities) {
    if (!byType.has(entity.type)) {
      byType.set(entity.type, []);
    }
    byType.get(entity.type)!.push(entity);
  }
  
  return { byId, byType };
};

/**
 * Creates a spatial index for fast geographic lookups
 * @param locations Array of locations to index
 * @returns Spatial index object
 */
export const createSpatialIndex = (locations: GeoLocation[]) => {
  // Simple grid-based spatial index
  const gridSize = 1; // 1 degree grid cells
  const grid = new Map<string, GeoLocation[]>();
  
  for (const location of locations) {
    const gridX = Math.floor(location.longitude / gridSize);
    const gridY = Math.floor(location.latitude / gridSize);
    const key = `${gridX}:${gridY}`;
    
    if (!grid.has(key)) {
      grid.set(key, []);
    }
    grid.get(key)!.push(location);
  }
  
  return {
    grid,
    queryByBounds: (bounds: any) => {
      // Implementation details
    }
  };
};

/**
 * Process data in chunks to avoid blocking the main thread
 * @param items Array of items to process
 * @param processFn Processing function for each item
 * @param chunkSize Number of items to process in each chunk
 * @returns Promise that resolves when processing is complete
 */
export const processInChunks = async <T, R>(
  items: T[],
  processFn: (item: T) => R,
  chunkSize = 100
): Promise<R[]> => {
  const results: R[] = [];
  
  for (let i = 0; i < items.length; i += chunkSize) {
    const chunk = items.slice(i, i + chunkSize);
    
    // Process chunk and allow UI thread to update
    await new Promise<void>(resolve => {
      setTimeout(() => {
        for (const item of chunk) {
          results.push(processFn(item));
        }
        resolve();
      }, 0);
    });
  }
  
  return results;
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test each utility function with various inputs
2. **Performance Testing**: Benchmark functions with large datasets
3. **Edge Case Testing**: Test with empty arrays, invalid inputs, etc.

Test files should be organized in the `tests` directory with appropriate subdirectories for unit tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
