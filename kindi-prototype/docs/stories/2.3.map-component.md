# Story 2.3: Map Component

## Status

Done

## Story

**As an** analyst,
**I want** to see geographic data on an interactive map,
**so that** I can understand spatial relationships.

## Acceptance Criteria

1: react-leaflet is integrated into the application
2: Locations are displayed as markers on the map
3: Multiple base map options are available (satellite, street, terrain)
4: Map supports standard zoom and pan functionality
5: Location markers are styled based on entity type
6: Map bounds adjust to show all relevant data points

## Tasks / Subtasks

- [x] Set up react-leaflet integration (AC: 1)
  - [x] Install react-leaflet and dependencies
  - [x] Create MapComponent wrapper for react-leaflet
  - [x] Configure basic map settings and properties
  - [x] Set up map container with appropriate dimensions

- [x] Implement location markers (AC: 2)
  - [x] Create marker component for locations
  - [x] Implement popup information for markers
  - [x] Add clustering for dense marker areas
  - [x] Create marker selection functionality

- [x] Implement base map options (AC: 3)
  - [x] Set up default OpenStreetMap layer
  - [x] Add satellite imagery layer
  - [x] Add terrain map layer
  - [x] Create layer control for switching between map types

- [x] Implement map navigation controls (AC: 4)
  - [x] Add zoom in/out controls
  - [x] Implement pan functionality
  - [x] Add fullscreen toggle
  - [x] Create home/reset view button

- [x] Implement marker styling system (AC: 5)
  - [x] Create custom markers based on entity types
  - [x] Implement color coding for different entity categories
  - [x] Add size variation based on importance
  - [x] Create marker legend for entity types

- [x] Implement automatic bounds adjustment (AC: 6)
  - [x] Create function to calculate bounds from visible markers
  - [x] Implement auto-fit functionality for initial load
  - [x] Add padding to ensure all markers are visible
  - [x] Create manual fit button to reset view

## Dev Notes

### Visualization Component Structure

[Source: architecture/technical-architecture-document.md#component-architecture]

The Map Component should be implemented in the visualization components directory:

```
app/
└── components/
    └── visualizations/
        └── map/
            ├── MapComponent.tsx         # Main map component
            ├── MapControls.tsx          # Zoom, layer controls
            ├── LocationMarker.tsx       # Custom marker component
            ├── MarkerCluster.tsx        # Clustering component
            └── MapLegend.tsx            # Entity type legend
```

### Data Transformation

[Source: architecture/technical-architecture-document.md#data-transformation-indexing]

Transform the location data into the format required by react-leaflet:

```typescript
// Transform locations to map markers
const transformLocationsToMarkers = (
  locations: GeoLocation[],
  entities: Entity[]
): MarkerData[] => {
  return locations.map(location => {
    // Find entities associated with this location
    const relatedEntities = entities.filter(
      entity => entity.attributes?.locationId === location.id
    );

    return {
      id: location.id,
      position: [location.latitude, location.longitude],
      name: location.name || 'Unnamed Location',
      type: location.type || 'CUSTOM',
      address: location.address,
      entities: relatedEntities.map(e => e.id),
      primaryEntityType: relatedEntities[0]?.type || 'LOCATION',
      attributes: location.attributes,
    };
  });
};
```

### react-leaflet Configuration

[Source: architecture/technical-architecture-document.md#visualization-libraries]

The react-leaflet library should be configured with the following options:

```typescript
<MapContainer
  center={defaultCenter}
  zoom={defaultZoom}
  style={{ height: '100%', width: '100%' }}
  whenCreated={setMapInstance}
>
  {/* Base map layers */}
  <LayersControl position="topright">
    <LayersControl.BaseLayer name="Street" checked>
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      />
    </LayersControl.BaseLayer>
    <LayersControl.BaseLayer name="Satellite">
      <TileLayer
        url="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
        attribution="Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community"
      />
    </LayersControl.BaseLayer>
    <LayersControl.BaseLayer name="Terrain">
      <TileLayer
        url="https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png"
        attribution='Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
      />
    </LayersControl.BaseLayer>
  </LayersControl>

  {/* Marker cluster group */}
  <MarkerClusterGroup>
    {markers.map(marker => (
      <LocationMarker
        key={marker.id}
        marker={marker}
        selected={selectedLocationIds.includes(marker.id)}
        onSelect={handleMarkerSelect}
      />
    ))}
  </MarkerClusterGroup>
</MapContainer>
```

### Marker Styling

Create a styling system for different location types:

```typescript
// Get marker icon based on entity type
const getMarkerIcon = (entityType: EntityType, selected: boolean): Icon => {
  const iconSize = selected ? [32, 32] : [24, 24];
  const iconColor = getColorForEntityType(entityType);

  return new Icon({
    iconUrl: `/markers/${entityType.toLowerCase()}.svg`,
    iconSize: iconSize,
    iconAnchor: [iconSize[0] / 2, iconSize[1]],
    popupAnchor: [0, -iconSize[1] / 2],
    className: selected ? 'selected-marker' : '',
  });
};
```

### Selection Integration

[Source: architecture/technical-architecture-document.md#synchronization-architecture]

The map component should integrate with the SelectionContext:

```typescript
const { selectedLocationIds, selectedEntityIds, selectLocation } = useContext(SelectionContext);

// Handle marker selection
const handleMarkerSelect = useCallback(
  locationId => {
    selectLocation(locationId);
  },
  [selectLocation]
);

// Filter and highlight markers based on selected entities
useEffect(() => {
  if (selectedEntityIds.length > 0) {
    const relatedLocationIds = markers
      .filter(marker => marker.entities.some(id => selectedEntityIds.includes(id)))
      .map(marker => marker.id);

    setHighlightedMarkers(relatedLocationIds);

    // Adjust map bounds to show selected markers
    if (mapInstance && relatedLocationIds.length > 0) {
      const points = relatedLocationIds
        .map(id => markers.find(m => m.id === id))
        .filter(Boolean)
        .map(marker => marker.position);

      if (points.length > 0) {
        const bounds = new LatLngBounds(points);
        mapInstance.fitBounds(bounds, { padding: [50, 50] });
      }
    }
  } else {
    setHighlightedMarkers([]);
  }
}, [selectedEntityIds, markers, mapInstance]);
```

### Testing

#### Testing Strategy

[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Component Testing**: Test the map component rendering and interactions
2. **Marker Handling**: Test marker creation, clustering, and styling
3. **Integration Testing**: Test integration with the data context and selection context

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log

| Date       | Version | Description         | Author       |
| ---------- | ------- | ------------------- | ------------ |
| 2023-06-18 | 0.1     | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4

### Debug Log References

Successfully resolved SSR issues by implementing proper dynamic imports and client-side rendering checks.

### Completion Notes List

- ✅ Successfully integrated react-leaflet for interactive mapping
- ✅ Implemented dynamic component loading to avoid SSR issues
- ✅ Created location markers with popups and entity association
- ✅ Added map controls for zoom, navigation, and layer switching
- ✅ Implemented marker styling system with entity type colors
- ✅ Created comprehensive map legend for marker types
- ✅ Integrated with DataContext and SelectionContext
- ✅ Added proper client-side rendering checks

### File List

- app/components/visualizations/map/MapComponent.tsx
- app/components/visualizations/map/MapControls.tsx
- app/components/visualizations/map/MapLegend.tsx
- app/components/visualizations/MapPanel.tsx (updated)

## QA Results
