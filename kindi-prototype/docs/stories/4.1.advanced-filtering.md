# Story 4.1: Advanced Filtering

## Status
Draft

## Story
**As an** analyst,
**I want** to create complex filters with multiple parameters,
**so that** I can precisely focus my analysis.

## Acceptance Criteria
1: Advanced filtering interface allows combining multiple filter types
2: Filters can be saved for future use
3: Filter history is maintained for easy toggling between states
4: Filter sets can be named and organized
5: Filter comparison view shows differences between filter states
6: Advanced filters can be shared via exportable configuration

## Tasks / Subtasks
- [x] Implement advanced filter interface (AC: 1)
  - [x] Create filter builder component
  - [x] Implement filter type selection
  - [x] Add parameter configuration for each filter type
  - [x] Create filter combination logic (AND/OR)

- [x] Implement filter saving functionality (AC: 2)
  - [x] Create filter save dialog
  - [x] Implement filter storage in local storage
  - [x] Add filter management interface
  - [x] Create filter loading functionality

- [x] Implement filter history (AC: 3)
  - [x] Create filter history tracking
  - [x] Implement undo/redo functionality
  - [x] Add filter state navigation
  - [x] Create filter history visualization

- [x] Implement filter organization (AC: 4)
  - [x] Create filter naming functionality
  - [x] Implement filter categorization
  - [x] Add filter sorting and grouping
  - [x] Create filter folders/collections

- [x] Implement filter comparison (AC: 5)
  - [x] Create filter comparison view
  - [x] Implement difference highlighting
  - [x] Add parameter-by-parameter comparison
  - [x] Create visual diff representation

- [x] Implement filter export/import (AC: 6)
  - [x] Create filter export functionality
  - [x] Implement JSON export format
  - [x] Add filter import functionality
  - [x] Create shareable filter links

## Dev Notes

### Advanced Filter Architecture
[Source: architecture/technical-architecture-document.md#core-state-contexts]

Extend the existing FilterContext with advanced filtering capabilities:

```typescript
// Advanced filter types
interface FilterCondition {
  id: string;
  type: 'entityType' | 'timeRange' | 'geographic' | 'attribute' | 'relationship';
  operator: 'equals' | 'contains' | 'greaterThan' | 'lessThan' | 'between' | 'in';
  field: string;
  value: any;
  negated?: boolean;
}

interface FilterGroup {
  id: string;
  type: 'group';
  operator: 'and' | 'or';
  conditions: (FilterCondition | FilterGroup)[];
}

type AdvancedFilter = FilterCondition | FilterGroup;

interface SavedFilter {
  id: string;
  name: string;
  description?: string;
  category?: string;
  filter: AdvancedFilter;
  createdAt: number;
  updatedAt: number;
}

// Extended filter context
interface AdvancedFilterContextType extends FilterContextType {
  advancedFilter: AdvancedFilter | null;
  setAdvancedFilter: (filter: AdvancedFilter | null) => void;
  savedFilters: SavedFilter[];
  saveFilter: (name: string, description?: string, category?: string) => string;
  updateSavedFilter: (id: string, updates: Partial<SavedFilter>) => void;
  deleteSavedFilter: (id: string) => void;
  applySavedFilter: (id: string) => void;
  filterHistory: AdvancedFilter[];
  historyPosition: number;
  goBack: () => void;
  goForward: () => void;
  exportFilter: (id?: string) => string;
  importFilter: (filterJson: string) => void;
}
```

### Filter Builder Component
Create a component for building complex filters:

```typescript
interface FilterBuilderProps {
  initialFilter?: AdvancedFilter;
  onChange: (filter: AdvancedFilter) => void;
}

const FilterBuilder: React.FC<FilterBuilderProps> = ({
  initialFilter,
  onChange
}) => {
  const [filter, setFilter] = useState<AdvancedFilter>(
    initialFilter || {
      id: generateId(),
      type: 'group',
      operator: 'and',
      conditions: []
    }
  );
  
  // Update parent component when filter changes
  useEffect(() => {
    onChange(filter);
  }, [filter, onChange]);
  
  // Add a new condition to a group
  const addCondition = (groupId: string) => {
    const newCondition: FilterCondition = {
      id: generateId(),
      type: 'entityType',
      operator: 'equals',
      field: 'type',
      value: null
    };
    
    setFilter(prevFilter => 
      updateFilterGroup(prevFilter, groupId, group => ({
        ...group,
        conditions: [...group.conditions, newCondition]
      }))
    );
  };
  
  // Add a new group to a group
  const addGroup = (parentGroupId: string) => {
    const newGroup: FilterGroup = {
      id: generateId(),
      type: 'group',
      operator: 'and',
      conditions: []
    };
    
    setFilter(prevFilter => 
      updateFilterGroup(prevFilter, parentGroupId, group => ({
        ...group,
        conditions: [...group.conditions, newGroup]
      }))
    );
  };
  
  // Update a condition
  const updateCondition = (
    conditionId: string,
    updates: Partial<FilterCondition>
  ) => {
    setFilter(prevFilter => 
      updateFilterCondition(prevFilter, conditionId, condition => ({
        ...condition,
        ...updates
      }))
    );
  };
  
  // Update a group's operator
  const updateGroupOperator = (groupId: string, operator: 'and' | 'or') => {
    setFilter(prevFilter => 
      updateFilterGroup(prevFilter, groupId, group => ({
        ...group,
        operator
      }))
    );
  };
  
  // Remove a condition or group
  const removeItem = (itemId: string) => {
    setFilter(prevFilter => removeFilterItem(prevFilter, itemId));
  };
  
  // Render the filter builder UI
  return (
    <div className="filter-builder">
      <FilterGroupComponent
        group={filter as FilterGroup}
        onAddCondition={addCondition}
        onAddGroup={addGroup}
        onUpdateCondition={updateCondition}
        onUpdateGroupOperator={updateGroupOperator}
        onRemoveItem={removeItem}
      />
    </div>
  );
};
```

### Filter Group Component
Create a component for rendering and managing filter groups:

```typescript
interface FilterGroupComponentProps {
  group: FilterGroup;
  onAddCondition: (groupId: string) => void;
  onAddGroup: (groupId: string) => void;
  onUpdateCondition: (conditionId: string, updates: Partial<FilterCondition>) => void;
  onUpdateGroupOperator: (groupId: string, operator: 'and' | 'or') => void;
  onRemoveItem: (itemId: string) => void;
  level?: number;
}

const FilterGroupComponent: React.FC<FilterGroupComponentProps> = ({
  group,
  onAddCondition,
  onAddGroup,
  onUpdateCondition,
  onUpdateGroupOperator,
  onRemoveItem,
  level = 0
}) => {
  return (
    <div className={`filter-group level-${level}`}>
      <div className="group-header">
        <select
          value={group.operator}
          onChange={e => onUpdateGroupOperator(group.id, e.target.value as 'and' | 'or')}
          className="group-operator"
        >
          <option value="and">AND</option>
          <option value="or">OR</option>
        </select>
        
        {level > 0 && (
          <button
            className="remove-group"
            onClick={() => onRemoveItem(group.id)}
          >
            Remove Group
          </button>
        )}
      </div>
      
      <div className="group-conditions">
        {group.conditions.map(condition => (
          <div key={condition.id} className="condition-wrapper">
            {condition.type === 'group' ? (
              <FilterGroupComponent
                group={condition as FilterGroup}
                onAddCondition={onAddCondition}
                onAddGroup={onAddGroup}
                onUpdateCondition={onUpdateCondition}
                onUpdateGroupOperator={onUpdateGroupOperator}
                onRemoveItem={onRemoveItem}
                level={level + 1}
              />
            ) : (
              <FilterConditionComponent
                condition={condition as FilterCondition}
                onUpdateCondition={updates => onUpdateCondition(condition.id, updates)}
                onRemove={() => onRemoveItem(condition.id)}
              />
            )}
          </div>
        ))}
      </div>
      
      <div className="group-actions">
        <button
          className="add-condition"
          onClick={() => onAddCondition(group.id)}
        >
          Add Condition
        </button>
        
        <button
          className="add-group"
          onClick={() => onAddGroup(group.id)}
        >
          Add Group
        </button>
      </div>
    </div>
  );
};
```

### Filter Condition Component
Create a component for rendering and managing filter conditions:

```typescript
interface FilterConditionComponentProps {
  condition: FilterCondition;
  onUpdateCondition: (updates: Partial<FilterCondition>) => void;
  onRemove: () => void;
}

const FilterConditionComponent: React.FC<FilterConditionComponentProps> = ({
  condition,
  onUpdateCondition,
  onRemove
}) => {
  // Get available fields based on condition type
  const getAvailableFields = () => {
    switch (condition.type) {
      case 'entityType':
        return [
          { value: 'type', label: 'Entity Type' },
          { value: 'name', label: 'Entity Name' },
          { value: 'risk', label: 'Risk Level' }
        ];
      case 'timeRange':
        return [
          { value: 'time', label: 'Event Time' },
          { value: 'endTime', label: 'Event End Time' }
        ];
      case 'geographic':
        return [
          { value: 'latitude', label: 'Latitude' },
          { value: 'longitude', label: 'Longitude' },
          { value: 'name', label: 'Location Name' }
        ];
      case 'attribute':
        return [
          { value: 'attributes.age', label: 'Age' },
          { value: 'attributes.nationality', label: 'Nationality' },
          { value: 'attributes.occupation', label: 'Occupation' }
          // This would ideally be dynamically generated based on dataset
        ];
      case 'relationship':
        return [
          { value: 'type', label: 'Relationship Type' },
          { value: 'strength', label: 'Relationship Strength' },
          { value: 'directed', label: 'Is Directed' }
        ];
      default:
        return [];
    }
  };
  
  // Get available operators based on field type
  const getAvailableOperators = () => {
    // This would depend on the field type
    return [
      { value: 'equals', label: 'Equals' },
      { value: 'contains', label: 'Contains' },
      { value: 'greaterThan', label: 'Greater Than' },
      { value: 'lessThan', label: 'Less Than' },
      { value: 'between', label: 'Between' },
      { value: 'in', label: 'In List' }
    ];
  };
  
  // Render value input based on operator and field
  const renderValueInput = () => {
    switch (condition.operator) {
      case 'equals':
      case 'contains':
        return (
          <input
            type="text"
            value={condition.value || ''}
            onChange={e => onUpdateCondition({ value: e.target.value })}
            className="condition-value"
          />
        );
      case 'greaterThan':
      case 'lessThan':
        return (
          <input
            type="number"
            value={condition.value || ''}
            onChange={e => onUpdateCondition({ value: parseFloat(e.target.value) })}
            className="condition-value"
          />
        );
      case 'between':
        return (
          <div className="between-values">
            <input
              type="number"
              value={condition.value?.[0] || ''}
              onChange={e => onUpdateCondition({
                value: [parseFloat(e.target.value), condition.value?.[1]]
              })}
              className="condition-value"
              placeholder="Min"
            />
            <span className="and-separator">and</span>
            <input
              type="number"
              value={condition.value?.[1] || ''}
              onChange={e => onUpdateCondition({
                value: [condition.value?.[0], parseFloat(e.target.value)]
              })}
              className="condition-value"
              placeholder="Max"
            />
          </div>
        );
      case 'in':
        return (
          <textarea
            value={Array.isArray(condition.value) ? condition.value.join(', ') : condition.value || ''}
            onChange={e => onUpdateCondition({
              value: e.target.value.split(',').map(v => v.trim())
            })}
            className="condition-value-list"
            placeholder="Comma-separated values"
          />
        );
      default:
        return null;
    }
  };
  
  return (
    <div className="filter-condition">
      <select
        value={condition.type}
        onChange={e => onUpdateCondition({ type: e.target.value as any })}
        className="condition-type"
      >
        <option value="entityType">Entity</option>
        <option value="timeRange">Time</option>
        <option value="geographic">Location</option>
        <option value="attribute">Attribute</option>
        <option value="relationship">Relationship</option>
      </select>
      
      <select
        value={condition.field}
        onChange={e => onUpdateCondition({ field: e.target.value })}
        className="condition-field"
      >
        {getAvailableFields().map(field => (
          <option key={field.value} value={field.value}>
            {field.label}
          </option>
        ))}
      </select>
      
      <select
        value={condition.operator}
        onChange={e => onUpdateCondition({ operator: e.target.value as any })}
        className="condition-operator"
      >
        {getAvailableOperators().map(op => (
          <option key={op.value} value={op.value}>
            {op.label}
          </option>
        ))}
      </select>
      
      {renderValueInput()}
      
      <label className="negated-checkbox">
        <input
          type="checkbox"
          checked={condition.negated || false}
          onChange={e => onUpdateCondition({ negated: e.target.checked })}
        />
        Not
      </label>
      
      <button
        className="remove-condition"
        onClick={onRemove}
      >
        Remove
      </button>
    </div>
  );
};
```

### Filter Storage and History
Implement filter storage and history management:

```typescript
/**
 * Save filter to local storage
 * @param name Filter name
 * @param filter Filter configuration
 * @param description Optional description
 * @param category Optional category
 * @returns ID of the saved filter
 */
export const saveFilterToStorage = (
  name: string,
  filter: AdvancedFilter,
  description?: string,
  category?: string
): string => {
  // Generate ID if new filter
  const id = `filter-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  
  const savedFilter: SavedFilter = {
    id,
    name,
    description,
    category,
    filter,
    createdAt: Date.now(),
    updatedAt: Date.now()
  };
  
  // Get existing filters
  const existingFilters = getSavedFilters();
  
  // Add new filter
  const updatedFilters = [...existingFilters, savedFilter];
  
  // Save to local storage
  localStorage.setItem('savedFilters', JSON.stringify(updatedFilters));
  
  return id;
};

/**
 * Get saved filters from local storage
 * @returns Array of saved filters
 */
export const getSavedFilters = (): SavedFilter[] => {
  try {
    const filters = localStorage.getItem('savedFilters');
    return filters ? JSON.parse(filters) : [];
  } catch (error) {
    console.error('Error reading saved filters:', error);
    return [];
  }
};

/**
 * Add filter state to history
 * @param filter Current filter state
 * @param historyPosition Current position in history
 * @param filterHistory Current filter history
 * @returns Updated history and position
 */
export const addFilterToHistory = (
  filter: AdvancedFilter,
  historyPosition: number,
  filterHistory: AdvancedFilter[]
): {
  newHistory: AdvancedFilter[];
  newPosition: number;
} => {
  // Remove any future history if we're not at the end
  const truncatedHistory = filterHistory.slice(0, historyPosition + 1);
  
  // Add new filter state
  const newHistory = [...truncatedHistory, filter];
  
  // Limit history size
  if (newHistory.length > 50) {
    newHistory.shift();
  }
  
  return {
    newHistory,
    newPosition: newHistory.length - 1
  };
};
```

### Filter Comparison
Implement filter comparison functionality:

```typescript
interface FilterDifference {
  type: 'added' | 'removed' | 'changed';
  path: string;
  oldValue?: any;
  newValue?: any;
}

/**
 * Compare two filters and find differences
 * @param filter1 First filter
 * @param filter2 Second filter
 * @returns Array of differences
 */
export const compareFilters = (
  filter1: AdvancedFilter,
  filter2: AdvancedFilter
): FilterDifference[] => {
  const differences: FilterDifference[] = [];
  
  // Compare filter properties
  compareFilterObjects(filter1, filter2, '', differences);
  
  return differences;
};

/**
 * Compare two filter objects recursively
 * @param obj1 First object
 * @param obj2 Second object
 * @param path Current path
 * @param differences Array to collect differences
 */
const compareFilterObjects = (
  obj1: any,
  obj2: any,
  path: string,
  differences: FilterDifference[]
): void => {
  // Get all keys from both objects
  const allKeys = new Set([
    ...Object.keys(obj1 || {}),
    ...Object.keys(obj2 || {})
  ]);
  
  for (const key of allKeys) {
    const currentPath = path ? `${path}.${key}` : key;
    
    // Skip id fields
    if (key === 'id') continue;
    
    // Check if key exists in both objects
    if (!(key in obj1)) {
      differences.push({
        type: 'added',
        path: currentPath,
        newValue: obj2[key]
      });
      continue;
    }
    
    if (!(key in obj2)) {
      differences.push({
        type: 'removed',
        path: currentPath,
        oldValue: obj1[key]
      });
      continue;
    }
    
    // Compare values
    const val1 = obj1[key];
    const val2 = obj2[key];
    
    if (typeof val1 !== typeof val2) {
      differences.push({
        type: 'changed',
        path: currentPath,
        oldValue: val1,
        newValue: val2
      });
    } else if (typeof val1 === 'object' && val1 !== null && val2 !== null) {
      // Recursively compare objects
      if (Array.isArray(val1) && Array.isArray(val2)) {
        // Compare arrays
        compareFilterArrays(val1, val2, currentPath, differences);
      } else {
        // Compare objects
        compareFilterObjects(val1, val2, currentPath, differences);
      }
    } else if (val1 !== val2) {
      differences.push({
        type: 'changed',
        path: currentPath,
        oldValue: val1,
        newValue: val2
      });
    }
  }
};

/**
 * Compare two arrays of filter objects
 * @param arr1 First array
 * @param arr2 Second array
 * @param path Current path
 * @param differences Array to collect differences
 */
const compareFilterArrays = (
  arr1: any[],
  arr2: any[],
  path: string,
  differences: FilterDifference[]
): void => {
  // For simplicity, just compare array lengths
  if (arr1.length !== arr2.length) {
    differences.push({
      type: 'changed',
      path,
      oldValue: `Array with ${arr1.length} items`,
      newValue: `Array with ${arr2.length} items`
    });
    return;
  }
  
  // Compare array items
  for (let i = 0; i < arr1.length; i++) {
    const itemPath = `${path}[${i}]`;
    
    if (typeof arr1[i] === 'object' && typeof arr2[i] === 'object') {
      compareFilterObjects(arr1[i], arr2[i], itemPath, differences);
    } else if (arr1[i] !== arr2[i]) {
      differences.push({
        type: 'changed',
        path: itemPath,
        oldValue: arr1[i],
        newValue: arr2[i]
      });
    }
  }
};
```

### Filter Export/Import
Implement filter export and import functionality:

```typescript
/**
 * Export filter to JSON string
 * @param filter Filter to export
 * @returns JSON string representation
 */
export const exportFilterToJson = (filter: AdvancedFilter): string => {
  return JSON.stringify(filter, null, 2);
};

/**
 * Import filter from JSON string
 * @param json JSON string representation
 * @returns Imported filter
 */
export const importFilterFromJson = (json: string): AdvancedFilter => {
  try {
    const filter = JSON.parse(json);
    
    // Validate filter structure
    if (!validateFilterStructure(filter)) {
      throw new Error('Invalid filter structure');
    }
    
    return filter;
  } catch (error) {
    console.error('Error importing filter:', error);
    throw new Error('Failed to import filter: Invalid JSON format');
  }
};

/**
 * Validate filter structure
 * @param filter Filter to validate
 * @returns True if valid, false otherwise
 */
const validateFilterStructure = (filter: any): boolean => {
  // Basic validation
  if (!filter || typeof filter !== 'object') {
    return false;
  }
  
  // Check required fields
  if (!filter.id || !filter.type) {
    return false;
  }
  
  // Validate based on type
  if (filter.type === 'group') {
    if (!filter.operator || !Array.isArray(filter.conditions)) {
      return false;
    }
    
    // Recursively validate conditions
    return filter.conditions.every(validateFilterStructure);
  } else {
    // Validate condition
    return (
      filter.operator &&
      filter.field !== undefined &&
      filter.value !== undefined
    );
  }
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test filter utility functions and comparison logic
2. **Component Testing**: Test filter builder components and interactions
3. **Integration Testing**: Test filter application and storage

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used
Claude 3.7 Sonnet

### Debug Log References
N/A

### Completion Notes List
- Implemented advanced filter data models and interfaces
- Created AdvancedFilterContext for managing filter state
- Implemented filter builder component with condition and group components
- Added filter saving and loading functionality with local storage
- Implemented filter history tracking with undo/redo functionality
- Created filter comparison view for comparing different filters
- Integrated advanced filtering panel into the Control Panel
- Implemented filter export/import functionality

### File List
- app/models/filter-types.ts (new)
- app/lib/filter/filterStorage.ts (new)
- app/contexts/AdvancedFilterContext.tsx (new)
- app/components/filters/FilterConditionComponent.tsx (new)
- app/components/filters/FilterGroupComponent.tsx (new)
- app/components/filters/FilterBuilder.tsx (new)
- app/components/filters/FilterComparisonView.tsx (new)
- app/components/filters/AdvancedFilteringPanel.tsx (new)
- app/components/layout/ControlPanel.tsx (modified)

## QA Results
