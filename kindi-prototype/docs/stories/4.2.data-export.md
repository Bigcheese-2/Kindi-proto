# Story 4.2: Data Export

## Status
Draft

## Story
**As an** analyst,
**I want** to export visualizations and data in various formats,
**so that** I can use them in reports or share with colleagues.

## Acceptance Criteria
1: Export graph visualization as PNG, SVG, and PDF
2: Export timeline visualization as PNG and PDF
3: Export map visualization as PNG and PDF
4: Export selected data as CSV and JSON
5: Export analysis report with visualizations and annotations
6: Option to include or exclude specific data elements in exports

## Tasks / Subtasks
- [ ] Implement graph export functionality (AC: 1)
  - [ ] Create PNG export for graph
  - [ ] Implement SVG export for graph
  - [ ] Add PDF export for graph
  - [ ] Create export options dialog

- [ ] Implement timeline export functionality (AC: 2)
  - [ ] Create PNG export for timeline
  - [ ] Implement PDF export for timeline
  - [ ] Add timeline export options

- [ ] Implement map export functionality (AC: 3)
  - [ ] Create PNG export for map
  - [ ] Implement PDF export for map
  - [ ] Add map export options

- [ ] Implement data export functionality (AC: 4)
  - [ ] Create CSV export for selected data
  - [ ] Implement JSON export for selected data
  - [ ] Add data selection interface for export

- [ ] Implement report export (AC: 5)
  - [ ] Create report template system
  - [ ] Implement visualization embedding in reports
  - [ ] Add annotation support in reports
  - [ ] Create PDF export for reports

- [ ] Implement export customization (AC: 6)
  - [ ] Create element selection interface
  - [ ] Implement inclusion/exclusion logic
  - [ ] Add export preview functionality
  - [ ] Create export configuration storage

## Dev Notes

### Export Architecture
[Source: architecture/technical-architecture-document.md#component-architecture]

Create a new export service module in the lib directory:

```
app/
└── lib/
    └── export/
        ├── exportService.ts       # Main export service
        ├── visualExport.ts        # Visual export utilities
        ├── dataExport.ts          # Data export utilities
        └── reportExport.ts        # Report export utilities
```

### Export Service Implementation
Implement the main export service:

```typescript
// Export format types
export type ImageFormat = 'png' | 'jpg' | 'svg';
export type DocumentFormat = 'pdf';
export type DataFormat = 'csv' | 'json';
export type ExportFormat = ImageFormat | DocumentFormat | DataFormat;

// Export options
export interface ExportOptions {
  format: ExportFormat;
  quality?: number;         // For image formats
  width?: number;           // For visual exports
  height?: number;          // For visual exports
  includeMetadata?: boolean; // Include metadata in exports
  filename?: string;        // Suggested filename
  selection?: string[];     // IDs of selected elements to include
}

// Export service
export class ExportService {
  /**
   * Export graph visualization
   * @param graphRef React ref to graph component
   * @param options Export options
   */
  async exportGraph(
    graphRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob | string> {
    if (!graphRef.current) {
      throw new Error('Graph reference is not available');
    }
    
    switch (options.format) {
      case 'png':
      case 'jpg':
        return this.exportGraphAsImage(graphRef, options);
      case 'svg':
        return this.exportGraphAsSVG(graphRef, options);
      case 'pdf':
        return this.exportGraphAsPDF(graphRef, options);
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }
  
  /**
   * Export timeline visualization
   * @param timelineRef React ref to timeline component
   * @param options Export options
   */
  async exportTimeline(
    timelineRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob | string> {
    if (!timelineRef.current) {
      throw new Error('Timeline reference is not available');
    }
    
    switch (options.format) {
      case 'png':
      case 'jpg':
        return this.exportTimelineAsImage(timelineRef, options);
      case 'pdf':
        return this.exportTimelineAsPDF(timelineRef, options);
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }
  
  /**
   * Export map visualization
   * @param mapRef React ref to map component
   * @param options Export options
   */
  async exportMap(
    mapRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob | string> {
    if (!mapRef.current) {
      throw new Error('Map reference is not available');
    }
    
    switch (options.format) {
      case 'png':
      case 'jpg':
        return this.exportMapAsImage(mapRef, options);
      case 'pdf':
        return this.exportMapAsPDF(mapRef, options);
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }
  
  /**
   * Export data in selected format
   * @param data Data to export
   * @param options Export options
   */
  async exportData(
    data: any,
    options: ExportOptions
  ): Promise<Blob | string> {
    switch (options.format) {
      case 'csv':
        return this.exportDataAsCSV(data, options);
      case 'json':
        return this.exportDataAsJSON(data, options);
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }
  }
  
  /**
   * Export analysis report
   * @param reportData Report data including visualizations and annotations
   * @param options Export options
   */
  async exportReport(
    reportData: any,
    options: ExportOptions
  ): Promise<Blob> {
    // Only PDF is supported for reports
    if (options.format !== 'pdf') {
      throw new Error('Reports can only be exported as PDF');
    }
    
    return this.generateReportPDF(reportData, options);
  }
  
  // Private implementation methods
  private async exportGraphAsImage(
    graphRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Implementation details for exporting graph as image
    // This would use html2canvas or a similar library
    const canvas = await html2canvas(graphRef.current);
    return new Promise<Blob>((resolve) => {
      canvas.toBlob(
        (blob) => resolve(blob as Blob),
        `image/${options.format}`,
        options.quality || 0.92
      );
    });
  }
  
  private exportGraphAsSVG(
    graphRef: React.RefObject<any>,
    options: ExportOptions
  ): string {
    // Implementation details for exporting graph as SVG
    // This would extract the SVG content from the graph component
    const svgElement = graphRef.current.getElementsByTagName('svg')[0];
    if (!svgElement) {
      throw new Error('SVG element not found in graph');
    }
    
    // Clone the SVG to avoid modifying the original
    const svgClone = svgElement.cloneNode(true) as SVGElement;
    
    // Add any necessary attributes
    svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
    
    // Convert to string
    const serializer = new XMLSerializer();
    return serializer.serializeToString(svgClone);
  }
  
  private async exportGraphAsPDF(
    graphRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Implementation details for exporting graph as PDF
    // This would use jsPDF or a similar library
    const canvas = await html2canvas(graphRef.current);
    const imgData = canvas.toDataURL('image/png');
    
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'px',
      format: [canvas.width, canvas.height]
    });
    
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    return pdf.output('blob');
  }
  
  // Similar methods for timeline and map exports
  private async exportTimelineAsImage(
    timelineRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Similar to exportGraphAsImage
    const canvas = await html2canvas(timelineRef.current);
    return new Promise<Blob>((resolve) => {
      canvas.toBlob(
        (blob) => resolve(blob as Blob),
        `image/${options.format}`,
        options.quality || 0.92
      );
    });
  }
  
  private async exportTimelineAsPDF(
    timelineRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Similar to exportGraphAsPDF
    const canvas = await html2canvas(timelineRef.current);
    const imgData = canvas.toDataURL('image/png');
    
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'px',
      format: [canvas.width, canvas.height]
    });
    
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    return pdf.output('blob');
  }
  
  private async exportMapAsImage(
    mapRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Similar to exportGraphAsImage
    const canvas = await html2canvas(mapRef.current);
    return new Promise<Blob>((resolve) => {
      canvas.toBlob(
        (blob) => resolve(blob as Blob),
        `image/${options.format}`,
        options.quality || 0.92
      );
    });
  }
  
  private async exportMapAsPDF(
    mapRef: React.RefObject<any>,
    options: ExportOptions
  ): Promise<Blob> {
    // Similar to exportGraphAsPDF
    const canvas = await html2canvas(mapRef.current);
    const imgData = canvas.toDataURL('image/png');
    
    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'px',
      format: [canvas.width, canvas.height]
    });
    
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
    return pdf.output('blob');
  }
  
  private exportDataAsCSV(
    data: any,
    options: ExportOptions
  ): string {
    // Implementation details for exporting data as CSV
    // Convert data to CSV format
    if (!data || !Array.isArray(data) || data.length === 0) {
      return '';
    }
    
    // Get headers from first object
    const headers = Object.keys(data[0]);
    
    // Create CSV content
    const csvContent = [
      // Headers row
      headers.join(','),
      // Data rows
      ...data.map(item => 
        headers.map(header => {
          const value = item[header];
          // Handle special cases (commas, quotes, etc.)
          if (value === null || value === undefined) {
            return '';
          }
          if (typeof value === 'string') {
            // Escape quotes and wrap in quotes if contains commas or quotes
            if (value.includes(',') || value.includes('"')) {
              return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
          }
          return String(value);
        }).join(',')
      )
    ].join('\n');
    
    return csvContent;
  }
  
  private exportDataAsJSON(
    data: any,
    options: ExportOptions
  ): string {
    // Implementation details for exporting data as JSON
    return JSON.stringify(data, null, 2);
  }
  
  private async generateReportPDF(
    reportData: any,
    options: ExportOptions
  ): Promise<Blob> {
    // Implementation details for generating a PDF report
    const { title, description, sections } = reportData;
    
    const pdf = new jsPDF();
    let yPos = 20;
    
    // Add title
    pdf.setFontSize(18);
    pdf.text(title, 20, yPos);
    yPos += 10;
    
    // Add description
    pdf.setFontSize(12);
    pdf.text(description, 20, yPos);
    yPos += 20;
    
    // Add sections
    for (const section of sections) {
      // Add section title
      pdf.setFontSize(14);
      pdf.text(section.title, 20, yPos);
      yPos += 10;
      
      // Add section content
      pdf.setFontSize(12);
      pdf.text(section.content, 20, yPos);
      yPos += 15;
      
      // Add section image if available
      if (section.image) {
        pdf.addImage(section.image, 'PNG', 20, yPos, 170, 100);
        yPos += 110;
      }
      
      // Add page break if needed
      if (yPos > 250) {
        pdf.addPage();
        yPos = 20;
      }
    }
    
    return pdf.output('blob');
  }
}
```

### Export Components
Create React components for the export functionality:

```typescript
interface ExportDialogProps {
  isOpen: boolean;
  onClose: () => void;
  exportType: 'graph' | 'timeline' | 'map' | 'data' | 'report';
  onExport: (options: ExportOptions) => void;
}

const ExportDialog: React.FC<ExportDialogProps> = ({
  isOpen,
  onClose,
  exportType,
  onExport
}) => {
  const [format, setFormat] = useState<ExportFormat>(
    exportType === 'data' ? 'csv' : 'png'
  );
  const [quality, setQuality] = useState<number>(90);
  const [includeMetadata, setIncludeMetadata] = useState<boolean>(true);
  const [filename, setFilename] = useState<string>(`kindi-${exportType}-export`);
  
  // Get available formats based on export type
  const getAvailableFormats = (): ExportFormat[] => {
    switch (exportType) {
      case 'graph':
        return ['png', 'svg', 'pdf'];
      case 'timeline':
      case 'map':
        return ['png', 'pdf'];
      case 'data':
        return ['csv', 'json'];
      case 'report':
        return ['pdf'];
      default:
        return ['png'];
    }
  };
  
  // Handle export button click
  const handleExport = () => {
    onExport({
      format,
      quality: quality / 100,
      includeMetadata,
      filename: `${filename}.${format}`
    });
    onClose();
  };
  
  return (
    <Dialog isOpen={isOpen} onClose={onClose} className="export-dialog">
      <div className="dialog-header">
        <h2>Export {exportType}</h2>
        <button className="close-button" onClick={onClose}>×</button>
      </div>
      
      <div className="dialog-content">
        <div className="form-group">
          <label htmlFor="format">Format</label>
          <select
            id="format"
            value={format}
            onChange={e => setFormat(e.target.value as ExportFormat)}
          >
            {getAvailableFormats().map(fmt => (
              <option key={fmt} value={fmt}>
                {fmt.toUpperCase()}
              </option>
            ))}
          </select>
        </div>
        
        {(format === 'png' || format === 'jpg') && (
          <div className="form-group">
            <label htmlFor="quality">Quality</label>
            <input
              type="range"
              id="quality"
              min="10"
              max="100"
              value={quality}
              onChange={e => setQuality(parseInt(e.target.value))}
            />
            <span>{quality}%</span>
          </div>
        )}
        
        <div className="form-group">
          <label htmlFor="filename">Filename</label>
          <input
            type="text"
            id="filename"
            value={filename}
            onChange={e => setFilename(e.target.value)}
          />
          <span>.{format}</span>
        </div>
        
        {(exportType === 'data' || exportType === 'report') && (
          <div className="form-group">
            <label>
              <input
                type="checkbox"
                checked={includeMetadata}
                onChange={e => setIncludeMetadata(e.target.checked)}
              />
              Include metadata
            </label>
          </div>
        )}
      </div>
      
      <div className="dialog-footer">
        <button className="cancel-button" onClick={onClose}>Cancel</button>
        <button className="export-button" onClick={handleExport}>Export</button>
      </div>
    </Dialog>
  );
};
```

### Export Button Component
Create a reusable export button component:

```typescript
interface ExportButtonProps {
  exportType: 'graph' | 'timeline' | 'map' | 'data' | 'report';
  onExport: (options: ExportOptions) => void;
  className?: string;
}

const ExportButton: React.FC<ExportButtonProps> = ({
  exportType,
  onExport,
  className
}) => {
  const [isDialogOpen, setIsDialogOpen] = useState<boolean>(false);
  
  return (
    <>
      <button
        className={`export-button ${className || ''}`}
        onClick={() => setIsDialogOpen(true)}
        title={`Export ${exportType}`}
      >
        <span className="export-icon">↓</span>
        <span className="export-label">Export</span>
      </button>
      
      <ExportDialog
        isOpen={isDialogOpen}
        onClose={() => setIsDialogOpen(false)}
        exportType={exportType}
        onExport={onExport}
      />
    </>
  );
};
```

### Report Template System
Create a report template system:

```typescript
interface ReportSection {
  id: string;
  title: string;
  content: string;
  image?: string; // Base64 encoded image data
  type: 'text' | 'graph' | 'timeline' | 'map' | 'data';
}

interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  sections: ReportSection[];
}

interface ReportData {
  title: string;
  description: string;
  author?: string;
  createdAt: number;
  sections: ReportSection[];
}

/**
 * Get available report templates
 * @returns Array of report templates
 */
export const getReportTemplates = (): ReportTemplate[] => {
  return [
    {
      id: 'basic',
      name: 'Basic Report',
      description: 'A simple report with title, description, and sections',
      sections: [
        {
          id: 'section-1',
          title: 'Overview',
          content: '',
          type: 'text'
        },
        {
          id: 'section-2',
          title: 'Graph Analysis',
          content: '',
          type: 'graph'
        },
        {
          id: 'section-3',
          title: 'Timeline Analysis',
          content: '',
          type: 'timeline'
        },
        {
          id: 'section-4',
          title: 'Geographic Analysis',
          content: '',
          type: 'map'
        },
        {
          id: 'section-5',
          title: 'Conclusions',
          content: '',
          type: 'text'
        }
      ]
    },
    {
      id: 'detailed',
      name: 'Detailed Analysis',
      description: 'A comprehensive report with detailed sections',
      sections: [
        {
          id: 'section-1',
          title: 'Executive Summary',
          content: '',
          type: 'text'
        },
        {
          id: 'section-2',
          title: 'Background',
          content: '',
          type: 'text'
        },
        {
          id: 'section-3',
          title: 'Network Analysis',
          content: '',
          type: 'graph'
        },
        {
          id: 'section-4',
          title: 'Key Entities',
          content: '',
          type: 'data'
        },
        {
          id: 'section-5',
          title: 'Chronological Analysis',
          content: '',
          type: 'timeline'
        },
        {
          id: 'section-6',
          title: 'Geographic Distribution',
          content: '',
          type: 'map'
        },
        {
          id: 'section-7',
          title: 'Findings',
          content: '',
          type: 'text'
        },
        {
          id: 'section-8',
          title: 'Recommendations',
          content: '',
          type: 'text'
        }
      ]
    }
  ];
};

/**
 * Create a new report from template
 * @param templateId Template ID
 * @param title Report title
 * @param description Report description
 * @returns New report data
 */
export const createReportFromTemplate = (
  templateId: string,
  title: string,
  description: string
): ReportData => {
  const templates = getReportTemplates();
  const template = templates.find(t => t.id === templateId);
  
  if (!template) {
    throw new Error(`Template not found: ${templateId}`);
  }
  
  return {
    title,
    description,
    createdAt: Date.now(),
    sections: template.sections.map(section => ({
      ...section,
      id: `section-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    }))
  };
};
```

### Integration with Visualization Components
Add export functionality to visualization components:

```typescript
// Example for the Graph component
const Graph: React.FC = () => {
  const graphRef = useRef<HTMLDivElement>(null);
  const exportService = useMemo(() => new ExportService(), []);
  
  const handleExport = useCallback(async (options: ExportOptions) => {
    try {
      const result = await exportService.exportGraph(graphRef, options);
      
      // Handle the export result based on format
      if (typeof result === 'string') {
        // For SVG format
        const blob = new Blob([result], { type: 'image/svg+xml' });
        saveAs(blob, options.filename || 'graph.svg');
      } else {
        // For binary formats (PNG, PDF)
        saveAs(result, options.filename || `graph.${options.format}`);
      }
    } catch (error) {
      console.error('Error exporting graph:', error);
      // Show error notification
    }
  }, [exportService]);
  
  return (
    <div className="graph-container">
      <div className="graph-header">
        <h3>Network Graph</h3>
        <ExportButton
          exportType="graph"
          onExport={handleExport}
        />
      </div>
      
      <div className="graph-content" ref={graphRef}>
        {/* Graph visualization */}
      </div>
    </div>
  );
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test export service methods and utility functions
2. **Component Testing**: Test export dialog and button components
3. **Integration Testing**: Test end-to-end export flow

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
