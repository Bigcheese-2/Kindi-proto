# Story 3.1: Selection Synchronization

## Status
Draft

## Story
**As an** analyst,
**I want** selections to be synchronized across all visualizations,
**so that** I can see the same entity from different perspectives.

## Acceptance Criteria
1: Selecting a node in the graph highlights related events in the timeline
2: Selecting a node in the graph highlights related locations on the map
3: Selecting an event in the timeline highlights related entities in the graph
4: Selecting an event in the timeline centers on related locations on the map
5: Selecting a location on the map highlights related entities in the graph
6: Selecting a location on the map highlights related events in the timeline

## Tasks / Subtasks
- [ ] Implement Selection Context (foundation for all ACs)
  - [ ] Create SelectionContext with React Context API
  - [ ] Define selection state for entities, events, and locations
  - [ ] Implement selection actions and reducers
  - [ ] Create SelectionProvider component

- [ ] Implement Graph selection integration (AC: 1, 2)
  - [ ] Add selection handlers to graph component
  - [ ] Implement visual highlighting for selected nodes
  - [ ] Create hooks for graph selection state
  - [ ] Connect graph selection to SelectionContext

- [ ] Implement Timeline selection integration (AC: 3, 4)
  - [ ] Add selection handlers to timeline component
  - [ ] Implement visual highlighting for selected events
  - [ ] Create hooks for timeline selection state
  - [ ] Connect timeline selection to SelectionContext

- [ ] Implement Map selection integration (AC: 5, 6)
  - [ ] Add selection handlers to map component
  - [ ] Implement visual highlighting for selected locations
  - [ ] Create hooks for map selection state
  - [ ] Connect map selection to SelectionContext

- [ ] Implement cross-visualization highlighting
  - [ ] Create entity-to-event mapping functionality
  - [ ] Implement entity-to-location mapping functionality
  - [ ] Add event-to-entity mapping functionality
  - [ ] Create event-to-location mapping functionality
  - [ ] Implement location-to-entity mapping functionality
  - [ ] Add location-to-event mapping functionality

- [ ] Create selection utilities and hooks
  - [ ] Implement useSelection hook for components
  - [ ] Create selection history functionality
  - [ ] Add multi-selection support
  - [ ] Implement selection clearing functionality

## Dev Notes

### Synchronization Architecture
[Source: architecture/technical-architecture-document.md#synchronization-architecture]

The synchronization between visualizations is a core feature of the platform. It should be implemented through:

1. **Selection Synchronization**: When an item is selected in one visualization, related items are highlighted in other visualizations
2. **Filter Synchronization**: Filters applied in the control panel affect all visualizations
3. **View Synchronization**: Zooming or focusing in one view can update others for context

The synchronization service acts as a mediator between visualization components:

```typescript
class SynchronizationService {
  // Notify all visualizations about selection changes
  notifySelectionChange(source: VisualizationType, selection: Selection): void;
  
  // Notify all visualizations about filter changes
  notifyFilterChange(filters: Filter[]): void;
  
  // Notify all visualizations about view changes (zoom, pan, etc.)
  notifyViewChange(source: VisualizationType, viewState: ViewState): void;
  
  // Register a visualization component to receive notifications
  registerVisualization(type: VisualizationType, callbacks: SyncCallbacks): void;
  
  // Unregister a visualization component
  unregisterVisualization(type: VisualizationType): void;
}
```

### Selection Context Implementation
[Source: architecture/technical-architecture-document.md#core-state-contexts]

Implement the SelectionContext as follows:

```typescript
// Selection types
type SelectionType = 'entity' | 'event' | 'location';

interface Selection {
  type: SelectionType;
  ids: string[];
  source: VisualizationType;
}

// Selection context
interface SelectionContextType {
  selectedEntityIds: string[];
  selectedEventIds: string[];
  selectedLocationIds: string[];
  selectEntity: (id: string, exclusive?: boolean) => void;
  selectEvent: (id: string, exclusive?: boolean) => void;
  selectLocation: (id: string, exclusive?: boolean) => void;
  clearSelection: () => void;
}

// Selection context provider
const SelectionContext = createContext<SelectionContextType>(initialSelectionContext);

const SelectionProvider: React.FC = ({ children }) => {
  const [selectedEntityIds, setSelectedEntityIds] = useState<string[]>([]);
  const [selectedEventIds, setSelectedEventIds] = useState<string[]>([]);
  const [selectedLocationIds, setSelectedLocationIds] = useState<string[]>([]);
  
  const selectEntity = useCallback((id: string, exclusive = true) => {
    setSelectedEntityIds(prev => exclusive ? [id] : [...prev, id]);
    // Find related events and locations
    // Update their selection state
  }, []);
  
  const selectEvent = useCallback((id: string, exclusive = true) => {
    setSelectedEventIds(prev => exclusive ? [id] : [...prev, id]);
    // Find related entities and locations
    // Update their selection state
  }, []);
  
  const selectLocation = useCallback((id: string, exclusive = true) => {
    setSelectedLocationIds(prev => exclusive ? [id] : [...prev, id]);
    // Find related entities and events
    // Update their selection state
  }, []);
  
  const clearSelection = useCallback(() => {
    setSelectedEntityIds([]);
    setSelectedEventIds([]);
    setSelectedLocationIds([]);
  }, []);
  
  const value = {
    selectedEntityIds,
    selectedEventIds,
    selectedLocationIds,
    selectEntity,
    selectEvent,
    selectLocation,
    clearSelection
  };
  
  return (
    <SelectionContext.Provider value={value}>
      {children}
    </SelectionContext.Provider>
  );
};
```

### Relationship Mapping
To synchronize selections across visualizations, implement mapping functions between different data types:

```typescript
/**
 * Find events related to an entity
 * @param entityId ID of the entity
 * @param events Array of events
 * @returns Array of event IDs related to the entity
 */
export const findRelatedEvents = (
  entityId: string,
  events: Event[]
): string[] => {
  return events
    .filter(event => event.entities.includes(entityId))
    .map(event => event.id);
};

/**
 * Find locations related to an entity
 * @param entityId ID of the entity
 * @param events Array of events
 * @returns Array of location IDs related to the entity
 */
export const findRelatedLocations = (
  entityId: string,
  events: Event[]
): string[] => {
  return events
    .filter(event => event.entities.includes(entityId))
    .filter(event => event.location)
    .map(event => event.location!.id);
};

/**
 * Find entities related to an event
 * @param eventId ID of the event
 * @param events Array of events
 * @returns Array of entity IDs related to the event
 */
export const findRelatedEntities = (
  eventId: string,
  events: Event[]
): string[] => {
  const event = events.find(e => e.id === eventId);
  return event ? event.entities : [];
};
```

### Custom Hooks
[Source: architecture/technical-architecture-document.md#custom-hooks]

Create a custom hook for selection:

```typescript
/**
 * Custom hook for selection functionality
 * @returns Selection context and helper functions
 */
export const useSelection = () => {
  const context = useContext(SelectionContext);
  
  if (!context) {
    throw new Error('useSelection must be used within a SelectionProvider');
  }
  
  const hasSelection = useMemo(() => {
    return (
      context.selectedEntityIds.length > 0 ||
      context.selectedEventIds.length > 0 ||
      context.selectedLocationIds.length > 0
    );
  }, [
    context.selectedEntityIds,
    context.selectedEventIds,
    context.selectedLocationIds
  ]);
  
  return {
    ...context,
    hasSelection
  };
};
```

### Visual Highlighting
Implement consistent visual highlighting across all visualizations:

```typescript
// Graph highlighting
const highlightSelectedNodes = (graphData, selectedEntityIds) => {
  return {
    ...graphData,
    nodes: graphData.nodes.map(node => ({
      ...node,
      highlighted: selectedEntityIds.includes(node.id),
      color: selectedEntityIds.includes(node.id) 
        ? highlightColors[node.type] 
        : normalColors[node.type]
    }))
  };
};

// Timeline highlighting
const highlightSelectedEvents = (timelineItems, selectedEventIds) => {
  return timelineItems.map(item => ({
    ...item,
    className: `${item.className} ${
      selectedEventIds.includes(item.id) ? 'selected-event' : ''
    }`
  }));
};

// Map highlighting
const highlightSelectedLocations = (markers, selectedLocationIds) => {
  return markers.map(marker => ({
    ...marker,
    selected: selectedLocationIds.includes(marker.id)
  }));
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test selection context and mapping functions
2. **Integration Testing**: Test synchronization between visualizations
3. **Component Testing**: Test visual highlighting in each visualization

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
