# Story 3.3: Filter Propagation

## Status
Draft

## Story
**As an** analyst,
**I want** filters applied in one component to affect all visualizations,
**so that** I can focus on specific subsets of data.

## Acceptance Criteria
1: Filters in the Control Panel affect all visualization components
2: Entity type filters update the graph, timeline, and map simultaneously
3: Time range filters update the graph, timeline, and map simultaneously
4: Geographic filters update the graph, timeline, and map simultaneously
5: Filter state is visually indicated in the interface
6: Filters can be cleared individually or all at once

## Tasks / Subtasks
- [ ] Implement Filter Context (foundation for all ACs)
  - [ ] Create FilterContext with React Context API
  - [ ] Define filter state for different filter types
  - [ ] Implement filter actions and reducers
  - [ ] Create FilterProvider component

- [ ] Create Control Panel filter components (AC: 1)
  - [ ] Implement EntityTypeFilter component
  - [ ] Create TimeRangeFilter component
  - [ ] Implement GeographicFilter component
  - [ ] Add filter section container in Control Panel

- [ ] Implement entity type filtering (AC: 2)
  - [ ] Create entity type selection UI
  - [ ] Implement entity type filter logic
  - [ ] Connect entity filter to graph component
  - [ ] Apply entity filters to timeline and map components

- [ ] Implement time range filtering (AC: 3)
  - [ ] Create date range picker component
  - [ ] Implement time range filter logic
  - [ ] Connect time filter to timeline component
  - [ ] Apply time filters to graph and map components

- [ ] Implement geographic filtering (AC: 4)
  - [ ] Create map region selection UI
  - [ ] Implement geographic filter logic
  - [ ] Connect geographic filter to map component
  - [ ] Apply geographic filters to graph and timeline components

- [ ] Implement filter state indicators (AC: 5)
  - [ ] Create active filter badges
  - [ ] Implement filter summary component
  - [ ] Add visual indicators for filtered state
  - [ ] Create filter count indicator

- [ ] Implement filter clearing functionality (AC: 6)
  - [ ] Add clear button for each filter type
  - [ ] Implement clear all filters button
  - [ ] Create filter reset confirmation
  - [ ] Add keyboard shortcuts for filter clearing

## Dev Notes

### Filter Architecture
[Source: architecture/technical-architecture-document.md#synchronization-architecture]

The filter propagation system should be implemented using a FilterContext and connected to the synchronization service:

```typescript
// Filter types
interface EntityTypeFilter {
  type: 'entityType';
  entityTypes: EntityType[];
}

interface TimeRangeFilter {
  type: 'timeRange';
  startTime: string | null;
  endTime: string | null;
}

interface GeographicFilter {
  type: 'geographic';
  region: {
    type: 'bounds' | 'radius';
    bounds?: {
      north: number;
      south: number;
      east: number;
      west: number;
    };
    center?: {
      latitude: number;
      longitude: number;
    };
    radiusKm?: number;
  };
}

type Filter = EntityTypeFilter | TimeRangeFilter | GeographicFilter;

// Filter context
interface FilterContextType {
  filters: Filter[];
  addFilter: (filter: Filter) => void;
  removeFilter: (id: string) => void;
  clearFilters: () => void;
  savedFilters: SavedFilter[];
  saveFilter: (name: string, filters: Filter[]) => void;
  applySavedFilter: (id: string) => void;
}
```

### Filter Context Implementation
[Source: architecture/technical-architecture-document.md#core-state-contexts]

Implement the FilterContext as follows:

```typescript
// Filter context
const FilterContext = createContext<FilterContextType>(initialFilterContext);

const FilterProvider: React.FC = ({ children }) => {
  const [filters, setFilters] = useState<Filter[]>([]);
  const [savedFilters, setSavedFilters] = useState<SavedFilter[]>([]);
  
  // Generate a unique ID for each filter
  const generateFilterId = () => {
    return `filter-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  };
  
  const addFilter = useCallback((filter: Omit<Filter, 'id'>) => {
    const newFilter = {
      ...filter,
      id: generateFilterId()
    };
    
    setFilters(prev => {
      // Remove any existing filter of the same type
      const filteredPrev = prev.filter(f => f.type !== filter.type);
      return [...filteredPrev, newFilter];
    });
  }, []);
  
  const removeFilter = useCallback((id: string) => {
    setFilters(prev => prev.filter(filter => filter.id !== id));
  }, []);
  
  const clearFilters = useCallback(() => {
    setFilters([]);
  }, []);
  
  const saveFilter = useCallback((name: string, filtersToSave: Filter[]) => {
    const newSavedFilter = {
      id: generateFilterId(),
      name,
      filters: filtersToSave
    };
    
    setSavedFilters(prev => [...prev, newSavedFilter]);
  }, []);
  
  const applySavedFilter = useCallback((id: string) => {
    const savedFilter = savedFilters.find(sf => sf.id === id);
    if (savedFilter) {
      setFilters(savedFilter.filters);
    }
  }, [savedFilters]);
  
  const value = {
    filters,
    addFilter,
    removeFilter,
    clearFilters,
    savedFilters,
    saveFilter,
    applySavedFilter
  };
  
  return (
    <FilterContext.Provider value={value}>
      {children}
    </FilterContext.Provider>
  );
};
```

### Filter Components
Create filter components for the Control Panel:

```typescript
// Entity Type Filter
const EntityTypeFilter: React.FC = () => {
  const { filters, addFilter } = useContext(FilterContext);
  const [selectedTypes, setSelectedTypes] = useState<EntityType[]>([]);
  
  // Find existing entity type filter
  const existingFilter = filters.find(
    filter => filter.type === 'entityType'
  ) as EntityTypeFilter | undefined;
  
  // Initialize selected types from existing filter
  useEffect(() => {
    if (existingFilter) {
      setSelectedTypes(existingFilter.entityTypes);
    }
  }, [existingFilter]);
  
  // Handle type selection changes
  const handleTypeChange = (type: EntityType, selected: boolean) => {
    const newSelectedTypes = selected
      ? [...selectedTypes, type]
      : selectedTypes.filter(t => t !== type);
    
    setSelectedTypes(newSelectedTypes);
    
    // Apply filter
    addFilter({
      type: 'entityType',
      entityTypes: newSelectedTypes
    });
  };
  
  return (
    <div className="entity-type-filter">
      <h3>Entity Types</h3>
      
      {Object.values(EntityType).map(type => (
        <div key={type} className="filter-checkbox">
          <input
            type="checkbox"
            id={`entity-type-${type}`}
            checked={selectedTypes.includes(type)}
            onChange={e => handleTypeChange(type, e.target.checked)}
          />
          <label htmlFor={`entity-type-${type}`}>
            {getEntityTypeLabel(type)}
          </label>
        </div>
      ))}
    </div>
  );
};

// Time Range Filter
const TimeRangeFilter: React.FC = () => {
  const { filters, addFilter } = useContext(FilterContext);
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  
  // Find existing time range filter
  const existingFilter = filters.find(
    filter => filter.type === 'timeRange'
  ) as TimeRangeFilter | undefined;
  
  // Initialize dates from existing filter
  useEffect(() => {
    if (existingFilter) {
      setStartDate(existingFilter.startTime ? new Date(existingFilter.startTime) : null);
      setEndDate(existingFilter.endTime ? new Date(existingFilter.endTime) : null);
    }
  }, [existingFilter]);
  
  // Apply filter when dates change
  const applyFilter = () => {
    addFilter({
      type: 'timeRange',
      startTime: startDate ? startDate.toISOString() : null,
      endTime: endDate ? endDate.toISOString() : null
    });
  };
  
  return (
    <div className="time-range-filter">
      <h3>Time Range</h3>
      
      <div className="date-inputs">
        <div className="date-input">
          <label htmlFor="start-date">Start Date</label>
          <DatePicker
            id="start-date"
            selected={startDate}
            onChange={date => {
              setStartDate(date);
              applyFilter();
            }}
            selectsStart
            startDate={startDate}
            endDate={endDate}
            dateFormat="yyyy-MM-dd"
          />
        </div>
        
        <div className="date-input">
          <label htmlFor="end-date">End Date</label>
          <DatePicker
            id="end-date"
            selected={endDate}
            onChange={date => {
              setEndDate(date);
              applyFilter();
            }}
            selectsEnd
            startDate={startDate}
            endDate={endDate}
            minDate={startDate}
            dateFormat="yyyy-MM-dd"
          />
        </div>
      </div>
      
      <div className="quick-ranges">
        <button onClick={() => {
          const range = createRelativeTimeRange('day', 7);
          setStartDate(range.startTime);
          setEndDate(range.endTime);
          applyFilter();
        }}>Last 7 Days</button>
        
        <button onClick={() => {
          const range = createRelativeTimeRange('month', 1);
          setStartDate(range.startTime);
          setEndDate(range.endTime);
          applyFilter();
        }}>Last Month</button>
        
        <button onClick={() => {
          const range = createRelativeTimeRange('year', 1);
          setStartDate(range.startTime);
          setEndDate(range.endTime);
          applyFilter();
        }}>Last Year</button>
      </div>
    </div>
  );
};
```

### Filter Application
Implement filter application in each visualization component:

```typescript
// In GraphComponent
const { filters } = useContext(FilterContext);
const { currentDataset } = useContext(DatasetContext);

// Apply filters to graph data
const filteredGraphData = useMemo(() => {
  if (!currentDataset) return { nodes: [], links: [] };
  
  let filteredEntities = [...currentDataset.entities];
  let filteredRelationships = [...currentDataset.relationships];
  
  // Apply each filter
  for (const filter of filters) {
    switch (filter.type) {
      case 'entityType':
        filteredEntities = filteredEntities.filter(entity => 
          filter.entityTypes.includes(entity.type)
        );
        // Filter relationships based on filtered entities
        filteredRelationships = filteredRelationships.filter(rel => 
          filteredEntities.some(e => e.id === rel.source) && 
          filteredEntities.some(e => e.id === rel.target)
        );
        break;
      
      case 'timeRange':
        // Filter entities based on events in the time range
        if (filter.startTime || filter.endTime) {
          const eventsInRange = filterEventsByTimeRange(
            currentDataset.events,
            filter.startTime,
            filter.endTime
          );
          
          const entityIdsInRange = new Set(
            eventsInRange.flatMap(event => event.entities)
          );
          
          filteredEntities = filteredEntities.filter(entity => 
            entityIdsInRange.has(entity.id)
          );
          
          // Filter relationships based on filtered entities
          filteredRelationships = filteredRelationships.filter(rel => 
            filteredEntities.some(e => e.id === rel.source) && 
            filteredEntities.some(e => e.id === rel.target)
          );
        }
        break;
      
      case 'geographic':
        // Filter entities based on locations in the region
        if (filter.region) {
          let locationsInRegion: GeoLocation[] = [];
          
          if (filter.region.type === 'bounds' && filter.region.bounds) {
            locationsInRegion = filterLocationsByBounds(
              currentDataset.locations,
              filter.region.bounds
            );
          } else if (
            filter.region.type === 'radius' && 
            filter.region.center && 
            filter.region.radiusKm
          ) {
            locationsInRegion = filterLocationsByRadius(
              currentDataset.locations,
              filter.region.center,
              filter.region.radiusKm
            );
          }
          
          const locationIds = new Set(
            locationsInRegion.map(location => location.id)
          );
          
          // Find events at these locations
          const eventsAtLocations = currentDataset.events.filter(event => 
            event.location && locationIds.has(event.location.id)
          );
          
          // Get entities involved in these events
          const entityIdsAtLocations = new Set(
            eventsAtLocations.flatMap(event => event.entities)
          );
          
          filteredEntities = filteredEntities.filter(entity => 
            entityIdsAtLocations.has(entity.id)
          );
          
          // Filter relationships based on filtered entities
          filteredRelationships = filteredRelationships.filter(rel => 
            filteredEntities.some(e => e.id === rel.source) && 
            filteredEntities.some(e => e.id === rel.target)
          );
        }
        break;
    }
  }
  
  // Transform to graph data format
  return transformForGraph(filteredEntities, filteredRelationships);
}, [currentDataset, filters]);
```

### Filter State Indicators
Create components to indicate active filters:

```typescript
const FilterBadge: React.FC<{ filter: Filter; onRemove: () => void }> = ({ 
  filter, 
  onRemove 
}) => {
  // Get filter description based on type
  const getFilterDescription = () => {
    switch (filter.type) {
      case 'entityType':
        return `Entity Types: ${filter.entityTypes.length} selected`;
      case 'timeRange':
        const start = filter.startTime ? new Date(filter.startTime).toLocaleDateString() : 'Any';
        const end = filter.endTime ? new Date(filter.endTime).toLocaleDateString() : 'Any';
        return `Time: ${start} to ${end}`;
      case 'geographic':
        return `Geographic: ${filter.region.type === 'bounds' ? 'Area' : 'Radius'}`;
      default:
        return 'Unknown Filter';
    }
  };
  
  return (
    <div className="filter-badge">
      <span className="filter-description">{getFilterDescription()}</span>
      <button className="remove-filter" onClick={onRemove}>Ã—</button>
    </div>
  );
};

const ActiveFilters: React.FC = () => {
  const { filters, removeFilter, clearFilters } = useContext(FilterContext);
  
  if (filters.length === 0) {
    return null;
  }
  
  return (
    <div className="active-filters">
      <div className="filters-header">
        <h3>Active Filters</h3>
        <button className="clear-all" onClick={clearFilters}>
          Clear All
        </button>
      </div>
      
      <div className="filter-badges">
        {filters.map(filter => (
          <FilterBadge
            key={filter.id}
            filter={filter}
            onRemove={() => removeFilter(filter.id)}
          />
        ))}
      </div>
    </div>
  );
};
```

### Testing

#### Testing Strategy
[Source: architecture/technical-architecture-document.md#testing-strategy]

For this story, focus on:

1. **Unit Testing**: Test filter context and filter utility functions
2. **Integration Testing**: Test filter application across visualizations
3. **Component Testing**: Test filter UI components and interactions

Test files should be organized in the `tests` directory with appropriate subdirectories for unit and integration tests.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2023-06-18 | 0.1 | Initial story draft | Scrum Master |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
